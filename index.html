<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Astro Chart Builder</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Inter:wght@400;500;600&display=swap');

:root {
  --bg:        #f7f4ef;
  --white:     #ffffff;
  --border:    #e0d8cc;
  --text:      #1a1510;
  --muted:     #7a6f62;
  --accent:    #5c4a2a;
  --red:       #b83232;
  --gold:      #d4a017;

  --sun:     #c47a0a;
  --moon:    #3d6494;
  --mercury: #6b2fae;
  --venus:   #a01248;
  --mars:    #b02020;
  --jupiter: #8a4a00;
  --saturn:  #1e6b5a;

  --chart-face: #fffef8;
  --ring-even:  #faf5ed;
  --ring-odd:   #f3ece0;
  --spoke:      #ccc0b0;
  --tick:       #b8a898;
  --sign-color: #9a8878;
}

*, *::before, *::after {
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  user-select: none;
  -webkit-user-select: none;
}

html, body {
  margin: 0; padding: 0;
  overscroll-behavior: none;
}

body {
  background: var(--bg);
  font-family: 'Inter', system-ui, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  padding: 18px 12px 36px;
  touch-action: pan-y;
}

.app { 
  width: 100%; 
  max-width: 420px; 
  display: flex; 
  flex-direction: column; 
  gap: 16px; 
  touch-action: pan-y;
}

.header {
  text-align: center;
  padding: 0 10px;
}
.header h1 {
  font-family: 'Cinzel', serif;
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 0.25em;
  color: var(--muted);
  text-transform: uppercase;
  margin: 0 0 4px;
}
.header p {
  font-size: 11px;
  color: var(--muted);
  margin: 0;
  opacity: 0.7;
}

.asc-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 12px;
  background: var(--white);
  border: 1px solid var(--border);
  border-radius: 10px;
}
.asc-label {
  font-family: 'Cinzel', serif;
  font-size: 10px;
  letter-spacing: 0.1em;
  color: var(--muted);
  text-transform: uppercase;
}
.asc-select {
  font-family: 'Cinzel', serif;
  font-size: 13px;
  color: var(--red);
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 6px 24px 6px 10px;
  cursor: pointer;
  outline: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 8px center;
  min-height: 36px;
}
.asc-select:focus {
  border-color: var(--accent);
}

.chart-wrap {
  width: 100%;
  aspect-ratio: 1;
  position: relative;
  touch-action: none;
  -webkit-touch-callout: none;
}

#chart-svg {
  width: 100%; height: 100%;
  display: block;
  border-radius: 50%;
  border: 1.5px solid var(--border);
  background: var(--chart-face);
  transition: border-color 0.2s;
}

.ring-even   { fill: var(--ring-even); }
.ring-odd    { fill: var(--ring-odd); }
.spoke       { stroke: var(--spoke); stroke-width: 1; }
.tick-minor  { stroke: var(--tick); stroke-width: 0.6; }
.tick-major  { stroke: var(--spoke); stroke-width: 1.2; }
.sign-sym    { font-size: 13px; fill: var(--sign-color); font-family: 'Cinzel', serif; cursor: default; }
.house-n     { font-size: 8px; fill: #bbb0a0; font-family: 'Inter', sans-serif; font-weight: 600; }
.asc-line    { stroke: var(--red); stroke-width: 2; stroke-linecap: round; }
.asc-lbl     { font-size: 9px; fill: var(--red); font-family: 'Cinzel', serif; font-weight: 600; }
.asc-zone    { fill: none; stroke: var(--red); stroke-width: 1.5; stroke-dasharray: 4,3; opacity: 0; transition: opacity 0.2s; }
.asc-zone.show { opacity: 0.4; }
.inner-ring  { fill: var(--chart-face); stroke: var(--spoke); stroke-width: 1; }

.p-glyph {
  font-size: 20px;
  text-anchor: middle;
  dominant-baseline: middle;
  cursor: grab;
  pointer-events: all;
}
.p-glyph:active { cursor: grabbing; }
.p-deg {
  font-size: 8px;
  fill: var(--muted);
  font-family: 'Inter', sans-serif;
  pointer-events: none;
  text-anchor: middle;
  dominant-baseline: middle;
}

.chart-wrap.over #chart-svg {
  border-color: var(--accent);
  background: #fefcf4;
  box-shadow: 0 0 0 3px rgba(92, 74, 42, 0.1);
}
.chart-wrap.asc-mode #chart-svg {
  border-color: var(--red);
  box-shadow: 0 0 0 3px rgba(184, 50, 50, 0.15);
}

#tip {
  position: fixed;
  z-index: 9999;
  pointer-events: none;
  background: var(--white);
  border: 1px solid var(--border);
  color: var(--text);
  font-family: 'Cinzel', serif;
  font-size: 10.5px;
  letter-spacing: 0.06em;
  padding: 4px 10px;
  border-radius: 6px;
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.12s;
  top: -99px; left: -99px;
  touch-action: none;
}
#tip.show { opacity: 1; }

.bank-row {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 7px;
  padding: 10px;
  background: var(--white);
  border: 1px solid var(--border);
  border-radius: 14px;
  overflow-x: auto;
  touch-action: pan-x;
}

.pcard {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  aspect-ratio: 1;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: var(--bg);
  touch-action: none;
  cursor: grab;
  transition: opacity 0.18s, border-color 0.15s, transform 0.1s;
  gap: 2px;
  min-width: 44px;
  min-height: 44px;
}
.pcard span.sym  { font-size: 20px; line-height: 1; display: block; pointer-events: none; }
.pcard span.lbl  {
  font-family: 'Cinzel', serif;
  font-size: 5px;
  letter-spacing: 0.04em;
  color: var(--muted);
  text-transform: uppercase;
  line-height: 1;
  pointer-events: none;
}
.pcard.used      { opacity: 0.2; filter: grayscale(1); pointer-events: none; }
.pcard.lifting   { opacity: 0.4; transform: scale(0.9); }
.pcard:active:not(.used) { transform: scale(0.95); }
.pcard.asc-card {
  border-color: var(--gold);
  background: #fffdf5;
}

#ghost {
  position: fixed;
  pointer-events: none;
  z-index: 9000;
  font-size: 36px;
  line-height: 1;
  transform: translate(-50%, -50%);
  opacity: 0;
  transition: opacity 0.1s;
  filter: drop-shadow(0 2px 8px rgba(0,0,0,0.2));
  touch-action: none;
}
#ghost.show { opacity: 0.9; }

.clear-btn {
  width: 100%;
  padding: 14px;
  border: 1px solid #f0d0d0;
  background: #fff8f8;
  color: var(--red);
  font-family: 'Cinzel', serif;
  font-size: 11px;
  letter-spacing: 0.12em;
  font-weight: 600;
  border-radius: 10px;
  cursor: pointer;
  touch-action: manipulation;
  transition: background 0.15s;
  min-height: 44px;
}
.clear-btn:active { background: #fdecea; }

.c-sun     { color: var(--sun);     fill: var(--sun); }
.c-moon    { color: var(--moon);    fill: var(--moon); }
.c-mercury { color: var(--mercury); fill: var(--mercury); }
.c-venus   { color: var(--venus);   fill: var(--venus); }
.c-mars    { color: var(--mars);    fill: var(--mars); }
.c-jupiter { color: var(--jupiter); fill: var(--jupiter); }
.c-saturn  { color: var(--saturn);  fill: var(--saturn); }

@media (max-width: 480px) {
  .header h1 { font-size: 13px; }
  .header p { font-size: 10px; }
  .pcard span.sym { font-size: 18px; }
  .p-glyph { font-size: 22px; }
  .asc-bar { padding: 10px; }
  .asc-select { font-size: 12px; padding: 5px 22px 5px 8px; }
}
</style>
</head>
<body>

<div id="ghost"></div>
<div id="tip"></div>

<div class="app">

  <div class="header">
    <h1>Astro Chart</h1>
    <p>Select ASC · Drag planets · Drop near left edge for ASC</p>
  </div>

  <div class="asc-bar">
    <span class="asc-label">ASC</span>
    <select class="asc-select" id="ascSelect">
      <option value="0">♈ Aries</option>
      <option value="1">♉ Taurus</option>
      <option value="2">♊ Gemini</option>
      <option value="3">♋ Cancer</option>
      <option value="4">♌ Leo</option>
      <option value="5">♍ Virgo</option>
      <option value="6">♎ Libra</option>
      <option value="7">♏ Scorpio</option>
      <option value="8">♐ Sagittarius</option>
      <option value="9">♑ Capricorn</option>
      <option value="10">♒ Aquarius</option>
      <option value="11">♓ Pisces</option>
    </select>
  </div>

  <div class="chart-wrap" id="chartWrap">
    <svg id="chart-svg" viewBox="0 0 400 400">
      <g id="g-sectors"></g>
      <g id="g-ticks"></g>
      <g id="g-signs"></g>
      <g id="g-asc"></g>
      <g id="g-planets"></g>
    </svg>
  </div>

  <div class="bank-row" id="bank">
    <div class="pcard c-sun"     data-pid="sun">     <span class="sym">☉</span><span class="lbl">Sun</span></div>
    <div class="pcard c-moon"    data-pid="moon">    <span class="sym">☽</span><span class="lbl">Moon</span></div>
    <div class="pcard c-mercury" data-pid="mercury"> <span class="sym">☿</span><span class="lbl">Merc</span></div>
    <div class="pcard c-venus"   data-pid="venus">   <span class="sym">♀</span><span class="lbl">Venus</span></div>
    <div class="pcard c-mars"    data-pid="mars">    <span class="sym">♂</span><span class="lbl">Mars</span></div>
    <div class="pcard c-jupiter" data-pid="jupiter"> <span class="sym">♃</span><span class="lbl">Jup</span></div>
    <div class="pcard c-saturn"  data-pid="saturn">  <span class="sym">♄</span><span class="lbl">Saturn</span></div>
  </div>

  <button class="clear-btn" id="clearBtn">✕  Clear Chart</button>
</div>

<script>
(function () {
'use strict';

const NS   = 'http://www.w3.org/2000/svg';
const CX   = 200, CY = 200;
const R_OUT = 183;
const R_ZOD = 162;
const R_ZOD_MID = 173;
const R_IN  = 140;
const R_PLANET = 110;
const R_INNER_FACE = 60;

let ASC_SIGN_INDEX = 0;
const ASC_DEG = 180;
const ASC_SNAP_RANGE = 25;

const SIGNS = ['♈','♉','♊','♋','♌','♍','♎','♏','♐','♑','♒','♓'];
const SIGN_NAMES = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo',
                    'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];
const PLANETS = {
  sun:     { sym:'☉', name:'Sun' },
  moon:    { sym:'☽', name:'Moon' },
  mercury: { sym:'☿', name:'Mercury' },
  venus:   { sym:'♀', name:'Venus' },
  mars:    { sym:'♂', name:'Mars' },
  jupiter: { sym:'♃', name:'Jupiter' },
  saturn:  { sym:'♄', name:'Saturn' },
};

const chartData = new Map();
let ascPlanet = null;

function el(tag, attrs, parent) {
  const e = document.createElementNS(NS, tag);
  for (const [k, v] of Object.entries(attrs || {})) e.setAttribute(k, v);
  if (parent) parent.appendChild(e);
  return e;
}

function chartToRad(chartDeg) {
  return ((chartDeg + ASC_DEG) % 360) * Math.PI / 180;
}

function polarXY(r, rad) {
  return { x: CX + r * Math.cos(rad), y: CY + r * Math.sin(rad) };
}

function clientToChartDeg(cx, cy) {
  const wrap = document.getElementById('chartWrap');
  const rect = wrap.getBoundingClientRect();
  const px = (cx - rect.left) / rect.width  * 400;
  const py = (cy - rect.top)  / rect.height * 400;
  const dx = px - CX, dy = py - CY;
  const screenRad = Math.atan2(dy, dx);
  const screenDeg = ((screenRad * 180 / Math.PI) + 360) % 360;
  const chartDeg  = ((screenDeg - ASC_DEG) + 360) % 360;
  return chartDeg;
}

function isOverChart(cx, cy) {
  const wrap = document.getElementById('chartWrap');
  const rect = wrap.getBoundingClientRect();
  const px = cx - rect.left, py = cy - rect.top;
  const dx = px - rect.width/2, dy = py - rect.height/2;
  const r2 = dx*dx + dy*dy;
  const maxR = rect.width / 2;
  return r2 <= maxR * maxR;
}

function getAscDegree() {
  return ASC_SIGN_INDEX * 30;
}

function isNearAsc(angleDeg) {
  const ascDeg = getAscDegree();
  let diff = Math.abs(angleDeg - ascDeg);
  if (diff > 180) diff = 360 - diff;
  return diff < ASC_SNAP_RANGE;
}

function describeArc(x, y, r, startAngle, endAngle) {
  const start = polarXY(r, chartToRad(startAngle));
  const end = polarXY(r, chartToRad(endAngle));
  const largeArc = endAngle - startAngle <= 180 ? 0 : 1;
  return `M ${start.x} ${start.y} A ${r} ${r} 0 ${largeArc} 1 ${end.x} ${end.y}`;
}

function buildChart() {
  const gSectors = document.getElementById('g-sectors');
  const gTicks   = document.getElementById('g-ticks');
  const gSigns   = document.getElementById('g-signs');
  const gAsc     = document.getElementById('g-asc');
  
  gSectors.innerHTML = '';
  gTicks.innerHTML = '';
  gSigns.innerHTML = '';
  gAsc.innerHTML = '';

  el('circle', { cx: CX, cy: CY, r: R_OUT, fill: '#fffef8', stroke: 'var(--spoke)', 'stroke-width': 1 }, gSectors);

  for (let i = 0; i < 12; i++) {
    const houseStart = i * 30;
    const houseEnd = (i + 1) * 30;
    const a1 = chartToRad(houseStart);
    const a2 = chartToRad(houseEnd);
    
    const p1 = polarXY(R_ZOD, a1), p2 = polarXY(R_ZOD, a2);
    const p3 = polarXY(R_IN,  a2), p4 = polarXY(R_IN,  a1);
    
    el('path', {
      d: `M${p1.x},${p1.y} A${R_ZOD},${R_ZOD} 0 0,1 ${p2.x},${p2.y} L${p3.x},${p3.y} A${R_IN},${R_IN} 0 0,0 ${p4.x},${p4.y}Z`,
      fill: i%2===0 ? 'var(--ring-even)' : 'var(--ring-odd)',
      stroke: 'var(--spoke)', 'stroke-width': '0.5'
    }, gSectors);

    const pi1 = polarXY(R_IN, a1), pi2 = polarXY(R_IN, a2);
    el('path', {
      d: `M${CX},${CY} L${pi1.x},${pi1.y} A${R_IN},${R_IN} 0 0,1 ${pi2.x},${pi2.y}Z`,
      fill: 'none',
      stroke: 'var(--spoke)', 'stroke-width': '0.5'
    }, gSectors);

    const midRad = chartToRad(houseStart + 15);
    const hn = polarXY(R_IN - 18, midRad);
    const houseNum = ((i - ASC_SIGN_INDEX + 12) % 12) + 1;
    const t = el('text', { x: hn.x, y: hn.y, class: 'house-n', 'text-anchor': 'middle', 'dominant-baseline': 'middle' }, gSectors);
    t.textContent = houseNum;

    const signIdx = (ASC_SIGN_INDEX + i) % 12;
    const sm = polarXY(R_ZOD_MID - 4, midRad);
    const st = el('text', { x: sm.x, y: sm.y, class: 'sign-sym', 'text-anchor': 'middle', 'dominant-baseline': 'middle' }, gSigns);
    st.textContent = SIGNS[signIdx];
    bindSignTooltip(st, signIdx);
  }

  for (let d = 0; d < 360; d++) {
    const a = chartToRad(d);
    const isMaj = d % 30 === 0;
    const isMid = d % 5  === 0;
    const len   = isMaj ? 11 : isMid ? 6 : 3.5;
    const p1 = polarXY(R_OUT,       a);
    const p2 = polarXY(R_OUT - len, a);
    el('line', { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, class: isMaj ? 'tick-major' : 'tick-minor' }, gTicks);
  }

  el('circle', { cx: CX, cy: CY, r: R_INNER_FACE, class: 'inner-ring' }, gSectors);

  const ascRad = chartToRad(getAscDegree());
  const a1 = polarXY(R_INNER_FACE, ascRad), a2 = polarXY(R_OUT + 4, ascRad);
  
  const zonePath = describeArc(CX, CY, R_OUT + 8, getAscDegree() - ASC_SNAP_RANGE, getAscDegree() + ASC_SNAP_RANGE);
  el('path', { d: zonePath, class: 'asc-zone', id: 'ascZone' }, gAsc);
  
  el('line', { x1: a1.x, y1: a1.y, x2: a2.x, y2: a2.y, class: 'asc-line' }, gAsc);
  
  const alp = polarXY(R_OUT + 14, ascRad);
  const at = el('text', { x: alp.x, y: alp.y, class: 'asc-lbl', 'text-anchor': 'middle', 'dominant-baseline': 'middle' }, gAsc);
  at.textContent = 'ASC';
}

function render() {
  const g = document.getElementById('g-planets');
  g.innerHTML = '';

  document.querySelectorAll('.pcard').forEach(card => {
    const pid = card.dataset.pid;
    const isUsed = chartData.has(pid);
    const isAsc = ascPlanet === pid;
    
    card.classList.toggle('used', isUsed && !isAsc);
    card.classList.toggle('asc-card', isAsc);
    card.classList.toggle('lifting', drag.active && drag.src === 'bank' && drag.pid === pid);
    
    const lbl = card.querySelector('.lbl');
    lbl.textContent = isAsc ? 'ASC' : PLANETS[pid].name.substring(0, 4);
  });

  const byBucket = new Map();
  chartData.forEach((deg, pid) => {
    const bucket = Math.round(deg / 5) * 5;
    if (!byBucket.has(bucket)) byBucket.set(bucket, []);
    byBucket.get(bucket).push(pid);
  });

  chartData.forEach((deg, pid) => {
    const bucket = Math.round(deg / 5) * 5;
    const group  = byBucket.get(bucket);
    const idx    = group.indexOf(pid);
    const r      = R_PLANET - idx * 22;
    const rad    = chartToRad(deg);
    const pos    = polarXY(r, rad);

    const signIdx = Math.floor(deg / 30);
    const degInSign = Math.floor(deg % 30);
    const isAsc = ascPlanet === pid;

    const pt = el('text', {
      x: pos.x, y: pos.y,
      class: `p-glyph c-${pid}`,
      'data-pid': pid,
      'text-anchor': 'middle',
      'dominant-baseline': 'middle',
      style: isAsc ? 'font-weight: bold; filter: drop-shadow(0 0 2px currentColor);' : ''
    }, g);
    pt.textContent = PLANETS[pid].sym;

    const degPos = polarXY(r - 16, rad);
    const dt = el('text', { x: degPos.x, y: degPos.y, class: 'p-deg' }, g);
    dt.textContent = isAsc ? 'ASC' : `${degInSign}°`;

    pt.addEventListener('mouseenter', e => showTip(makePlanetTip(pid, deg, isAsc), e.clientX, e.clientY));
    pt.addEventListener('mousemove',  e => moveTip(e.clientX, e.clientY));
    pt.addEventListener('mouseleave', hideTip);

    pt.addEventListener('mousedown', e => {
      e.preventDefault();
      startDrag('chart', pid, e.clientX, e.clientY);
    });
    
    // Touch events for planets - attached directly to element
    pt.addEventListener('touchstart', e => {
      if (e.touches.length !== 1) return;
      e.preventDefault(); // Prevent scroll immediately for planets
      handlePlanetTouchStart(e, pid);
    }, { passive: false });

    pt.addEventListener('dblclick', () => {
      if (ascPlanet === pid) ascPlanet = null;
      chartData.delete(pid);
      render();
    });
  });
}

function makePlanetTip(pid, deg, isAsc) {
  const s = Math.floor(deg / 30);
  const d = Math.floor(deg % 30);
  const signName = SIGN_NAMES[s];
  if (isAsc) return `${PLANETS[pid].name} · ${signName} ASC · ${d}°`;
  return `${PLANETS[pid].name} · ${signName} ${d}°`;
}

const tipEl = document.getElementById('tip');
let tipTimer = null;

function showTip(text, cx, cy) {
  clearTimeout(tipTimer);
  tipEl.textContent = text;
  tipEl.classList.add('show');
  moveTip(cx, cy);
}
function moveTip(cx, cy) {
  tipEl.style.left = '-999px';
  tipEl.style.top  = '-999px';
  const tw = tipEl.offsetWidth, th = tipEl.offsetHeight;
  let tx = cx + 12, ty = cy - th - 8;
  if (tx + tw > window.innerWidth - 6) tx = cx - tw - 12;
  if (ty < 4) ty = cy + 14;
  tipEl.style.left = tx + 'px';
  tipEl.style.top  = ty + 'px';
}
function hideTip() {
  tipTimer = setTimeout(() => tipEl.classList.remove('show'), 80);
}

function bindSignTooltip(el, idx) {
  el.addEventListener('mouseenter', e => showTip(SIGN_NAMES[idx], e.clientX, e.clientY));
  el.addEventListener('mousemove',  e => moveTip(e.clientX, e.clientY));
  el.addEventListener('mouseleave', hideTip);
}

const ghostEl = document.getElementById('ghost');

function showGhost(sym, cx, cy) {
  ghostEl.textContent = sym;
  ghostEl.style.left  = cx + 'px';
  ghostEl.style.top   = cy + 'px';
  ghostEl.classList.add('show');
}
function moveGhost(cx, cy) {
  ghostEl.style.left = cx + 'px';
  ghostEl.style.top  = cy + 'px';
}
function hideGhost() {
  ghostEl.classList.remove('show');
}

const drag = {
  active: false,
  src:    null,
  pid:    null,
  touchId: null,
  lastTap: new Map(),
  touchStartPos: null,
  hasMoved: false,
};

function startDrag(src, pid, cx, cy) {
  drag.active = true;
  drag.src    = src;
  drag.pid    = pid;
  drag.hasMoved = false;
  drag.touchStartPos = { x: cx, y: cy };
  hideTip();
  showGhost(PLANETS[pid].sym, cx, cy);
  
  document.getElementById('ascZone').classList.add('show');
  document.getElementById('chartWrap').classList.add('asc-mode');
  
  if (src === 'chart') {
    if (ascPlanet === pid) ascPlanet = null;
    chartData.delete(pid);
  }
  render();
}

function moveDragTo(cx, cy) {
  moveGhost(cx, cy);
  const wrap = document.getElementById('chartWrap');
  wrap.classList.toggle('over', isOverChart(cx, cy));
  
  const deg = clientToChartDeg(cx, cy);
  ghostEl.style.color = isNearAsc(deg) ? 'var(--red)' : '';
}

function endDrag(cx, cy) {
  if (!drag.active) return;
  drag.active = false;
  hideGhost();
  
  document.getElementById('ascZone').classList.remove('show');
  document.getElementById('chartWrap').classList.remove('asc-mode');
  
  const wrap = document.getElementById('chartWrap');
  wrap.classList.remove('over');

  if (isOverChart(cx, cy)) {
    let deg = clientToChartDeg(cx, cy);
    
    if (isNearAsc(deg)) {
      deg = getAscDegree();
      ascPlanet = drag.pid;
    }
    
    chartData.set(drag.pid, deg);
  } else if (drag.src === 'chart') {
    if (ascPlanet === drag.pid) ascPlanet = null;
  }

  drag.pid = null;
  drag.src = null;
  drag.touchId = null;
  drag.hasMoved = false;
  render();
}

function cancelDrag() {
  if (!drag.active) return;
  drag.active = false;
  drag.pid = null;
  drag.src = null;
  drag.touchId = null;
  drag.hasMoved = false;
  hideGhost();
  document.getElementById('ascZone').classList.remove('show');
  document.getElementById('chartWrap').classList.remove('asc-mode');
  document.getElementById('chartWrap').classList.remove('over');
  render();
}

// Mouse events for bank cards
document.querySelectorAll('.pcard').forEach(card => {
  card.setAttribute('draggable', 'true');
  card.addEventListener('mousedown', e => {
    if (card.classList.contains('used')) return;
    e.preventDefault();
    startDrag('bank', card.dataset.pid, e.clientX, e.clientY);
  });
  card.addEventListener('dragstart', e => {
    e.dataTransfer.setData('text/plain', card.dataset.pid);
  });
});

window.addEventListener('mousemove', e => {
  if (!drag.active) return;
  moveDragTo(e.clientX, e.clientY);
});

window.addEventListener('mouseup', e => {
  if (!drag.active) return;
  endDrag(e.clientX, e.clientY);
});

const chartWrap = document.getElementById('chartWrap');
chartWrap.addEventListener('dragover',  e => { e.preventDefault(); chartWrap.classList.add('over'); });
chartWrap.addEventListener('dragleave', () => chartWrap.classList.remove('over'));
chartWrap.addEventListener('drop', e => {
  e.preventDefault();
  chartWrap.classList.remove('over');
  const pid = e.dataTransfer.getData('text/plain');
  if (!pid) return;
  
  let deg = clientToChartDeg(e.clientX, e.clientY);
  if (isNearAsc(deg)) {
    deg = getAscDegree();
    ascPlanet = pid;
  }
  chartData.set(pid, deg);
  render();
});

// Touch handling for planets on chart
function handlePlanetTouchStart(e, pid) {
  const t = e.touches[0];
  drag.touchId = t.identifier;
  drag.touchStartPos = { x: t.clientX, y: t.clientY };
  drag.hasMoved = false;
  
  // Check for double tap
  const now = Date.now();
  const prev = drag.lastTap.get(pid) || 0;
  if (now - prev < 300) {
    // Double tap - remove planet
    if (ascPlanet === pid) ascPlanet = null;
    chartData.delete(pid);
    drag.lastTap.delete(pid);
    render();
    return;
  }
  drag.lastTap.set(pid, now);
  
  // Start drag immediately for planets
  startDrag('chart', pid, t.clientX, t.clientY);
}

// Global touch handlers for ongoing drag
function onTouchMove(e) {
  if (!drag.active) return;
  
  const t = findTouch(e.touches, drag.touchId) || findTouch(e.changedTouches, drag.touchId);
  if (!t) return;
  
  e.preventDefault();
  moveDragTo(t.clientX, t.clientY);
}

function onTouchEnd(e) {
  if (!drag.active) return;
  
  const t = findTouch(e.changedTouches, drag.touchId);
  if (!t) return;
  
  e.preventDefault();
  endDrag(t.clientX, t.clientY);
  drag.touchId = null;
}

function onTouchCancel(e) {
  if (drag.active) {
    cancelDrag();
  }
  drag.touchId = null;
}

function findTouch(list, id) {
  for (let i = 0; i < list.length; i++) {
    if (list[i].identifier === id) return list[i];
  }
  return null;
}

// Attach global touch handlers
document.addEventListener('touchmove', onTouchMove, { passive: false });
document.addEventListener('touchend', onTouchEnd, { passive: false });
document.addEventListener('touchcancel', onTouchCancel, { passive: false });

// Touch handling for bank cards - using direct attachment with delegation fallback
function initBankTouch() {
  const bank = document.getElementById('bank');
  
  bank.addEventListener('touchstart', e => {
    if (e.touches.length !== 1) return;
    const t = e.touches[0];
    const card = t.target.closest('.pcard');
    
    if (card && !card.classList.contains('used')) {
      e.preventDefault(); // Prevent scroll on bank cards
      drag.touchId = t.identifier;
      drag.touchStartPos = { x: t.clientX, y: t.clientY };
      drag.hasMoved = false;
      drag.potentialPid = card.dataset.pid;
      drag.potentialSrc = 'bank';
    }
  }, { passive: false });
  
  bank.addEventListener('touchmove', e => {
    if (!drag.touchId || drag.active) return;
    
    const t = findTouch(e.touches, drag.touchId) || findTouch(e.changedTouches, drag.touchId);
    if (!t) return;
    
    const dx = t.clientX - drag.touchStartPos.x;
    const dy = t.clientY - drag.touchStartPos.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    // Start drag after moving 10px
    if (dist > 10 && drag.potentialPid) {
      e.preventDefault();
      startDrag('bank', drag.potentialPid, drag.touchStartPos.x, drag.touchStartPos.y);
      moveDragTo(t.clientX, t.clientY);
    }
  }, { passive: false });
  
  bank.addEventListener('touchend', e => {
    if (!drag.touchId) return;
    
    const t = findTouch(e.changedTouches, drag.touchId);
    if (!t) {
      drag.touchId = null;
      drag.potentialPid = null;
      return;
    }
    
    // If we didn't start dragging, it was just a tap - ignore
    if (!drag.active && drag.potentialPid) {
      drag.touchId = null;
      drag.potentialPid = null;
      drag.hasMoved = false;
    }
  }, { passive: false });
}

// Chart touch handling for new drops (when not dragging a planet)
chartWrap.addEventListener('touchstart', e => {
  // Only handle if we're not already dragging and not touching a planet
  if (drag.active || e.touches.length !== 1) return;
  
  const t = e.touches[0];
  const target = document.elementFromPoint(t.clientX, t.clientY);
  
  // Check if touching a planet glyph
  let node = target;
  while (node && node !== chartWrap) {
    if (node.classList && node.classList.contains('p-glyph')) {
      // Planet touch is handled by the element's own listener
      return;
    }
    node = node.parentNode;
  }
}, { passive: true });

// ASC Dropdown
document.getElementById('ascSelect').addEventListener('change', (e) => {
  ASC_SIGN_INDEX = parseInt(e.target.value);
  buildChart();
  render();
});

document.getElementById('clearBtn').addEventListener('click', () => {
  chartData.clear();
  ascPlanet = null;
  render();
});

// Initialize
initBankTouch();
buildChart();
render();

})();
</script>
</body>
</html>
