<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Astro Chart Builder</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Inter:wght@400;500;600&display=swap');

:root {
  --bg:        #f7f4ef;
  --white:     #ffffff;
  --border:    #e0d8cc;
  --text:      #1a1510;
  --muted:     #7a6f62;
  --accent:    #5c4a2a;
  --red:       #b83232;

  --sun:     #c47a0a;
  --moon:    #3d6494;
  --mercury: #6b2fae;
  --venus:   #a01248;
  --mars:    #b02020;
  --jupiter: #8a4a00;
  --saturn:  #1e6b5a;

  --chart-face: #fffef8;
  --ring-even:  #faf5ed;
  --ring-odd:   #f3ece0;
  --spoke:      #ccc0b0;
  --tick:       #b8a898;
  --sign-color: #9a8878;
}

*, *::before, *::after {
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  user-select: none;
  -webkit-user-select: none;
}

/* Allow normal page scroll but let JS steal touches when needed */
html { overscroll-behavior: none; }
body {
  margin: 0; padding: 18px 12px 36px;
  background: var(--bg);
  font-family: 'Inter', system-ui, sans-serif;
  display: flex; flex-direction: column; align-items: center;
  min-height: 100vh;
  /* pan-y: page can scroll vertically when NOT dragging a planet */
  touch-action: pan-y;
}

.app {
  width: 100%; max-width: 420px;
  display: flex; flex-direction: column; gap: 16px;
  touch-action: pan-y;
}

.header { text-align: center; padding: 0 10px; }
.header h1 {
  font-family: 'Cinzel', serif; font-size: 14px; font-weight: 600;
  letter-spacing: 0.25em; color: var(--muted); text-transform: uppercase;
  margin: 0 0 4px;
}
.header p { font-size: 11px; color: var(--muted); margin: 0; opacity: 0.7; }

/* ASC Selector */
.asc-bar {
  display: flex; align-items: center; justify-content: center; gap: 10px;
  padding: 12px; background: var(--white);
  border: 1px solid var(--border); border-radius: 10px;
  touch-action: manipulation;
}
.asc-label {
  font-family: 'Cinzel', serif; font-size: 10px;
  letter-spacing: 0.1em; color: var(--muted); text-transform: uppercase;
}
.asc-select {
  font-family: 'Cinzel', serif; font-size: 13px; color: var(--red);
  background: var(--bg); border: 1px solid var(--border); border-radius: 6px;
  padding: 6px 24px 6px 10px; cursor: pointer; outline: none; appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat; background-position: right 8px center; min-height: 36px;
  touch-action: manipulation;
}

/* Chart */
.chart-wrap {
  width: 100%; aspect-ratio: 1; position: relative;
  /* CRITICAL: touch-action:none so the browser NEVER scrolls while finger is
     on the chart — we own every touch here */
  touch-action: none;
}

#chart-svg {
  width: 100%; height: 100%; display: block;
  border-radius: 50%; border: 1.5px solid var(--border);
  background: var(--chart-face); transition: border-color 0.2s;
}
.chart-wrap.over #chart-svg { border-color: var(--accent); background: #fefcf4; }

/* SVG classes */
.tick-minor { stroke: var(--tick); stroke-width: 0.6; }
.tick-major { stroke: var(--spoke); stroke-width: 1.2; }
.sign-sym   { font-size: 13px; fill: var(--sign-color); font-family: 'Cinzel', serif; cursor: default; }
.house-n    { font-size: 8px; fill: #bbb0a0; font-family: 'Inter', sans-serif; font-weight: 600; }
.asc-line   { stroke: var(--red); stroke-width: 2; stroke-linecap: round; }
.asc-lbl    { font-size: 9px; fill: var(--red); font-family: 'Cinzel', serif; font-weight: 600; }
.inner-ring { fill: var(--chart-face); stroke: var(--spoke); stroke-width: 1; }

.p-glyph {
  font-size: 20px; text-anchor: middle; dominant-baseline: middle;
  cursor: grab; pointer-events: all;
}
.p-deg {
  font-size: 8px; fill: var(--muted); font-family: 'Inter', sans-serif;
  pointer-events: none; text-anchor: middle; dominant-baseline: middle;
}

/* Tooltip */
#tip {
  position: fixed; z-index: 9999; pointer-events: none;
  background: var(--white); border: 1px solid var(--border); color: var(--text);
  font-family: 'Cinzel', serif; font-size: 10.5px; letter-spacing: 0.06em;
  padding: 4px 10px; border-radius: 6px; white-space: nowrap;
  opacity: 0; transition: opacity 0.12s; top: -99px; left: -99px;
}
#tip.show { opacity: 1; }

/* Planet bank */
.bank-row {
  display: grid; grid-template-columns: repeat(7, 1fr); gap: 7px;
  padding: 10px; background: var(--white);
  border: 1px solid var(--border); border-radius: 14px;
  /* touch-action:none — we handle all touches on the cards ourselves */
  touch-action: none;
}

.pcard {
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; aspect-ratio: 1; border-radius: 10px;
  border: 1px solid var(--border); background: var(--bg);
  /* none — we fully own touches */
  touch-action: none;
  cursor: grab; gap: 2px; min-width: 40px; min-height: 40px;
  transition: opacity 0.18s, transform 0.1s;
}
.pcard span.sym { font-size: 19px; line-height: 1; display: block; pointer-events: none; }
.pcard span.lbl {
  font-family: 'Cinzel', serif; font-size: 5px; letter-spacing: 0.04em;
  color: var(--muted); text-transform: uppercase; line-height: 1; pointer-events: none;
}
.pcard.used    { opacity: 0.2; filter: grayscale(1); pointer-events: none; }
.pcard.lifting { opacity: 0.35; transform: scale(0.88); }

/* Floating ghost that follows finger/cursor */
#ghost {
  position: fixed; pointer-events: none; z-index: 9000;
  font-size: 36px; line-height: 1;
  /* offset so glyph is above the finger tip */
  transform: translate(-50%, -70%);
  opacity: 0; transition: opacity 0.08s;
}
#ghost.show { opacity: 0.9; }

/* Clear button */
.clear-btn {
  width: 100%; padding: 14px; border: 1px solid #f0d0d0; background: #fff8f8;
  color: var(--red); font-family: 'Cinzel', serif; font-size: 11px;
  letter-spacing: 0.12em; font-weight: 600; border-radius: 10px;
  cursor: pointer; touch-action: manipulation; min-height: 44px;
  transition: background 0.15s;
}
.clear-btn:active { background: #fdecea; }

/* Colour tokens */
.c-sun     { color: var(--sun);     fill: var(--sun); }
.c-moon    { color: var(--moon);    fill: var(--moon); }
.c-mercury { color: var(--mercury); fill: var(--mercury); }
.c-venus   { color: var(--venus);   fill: var(--venus); }
.c-mars    { color: var(--mars);    fill: var(--mars); }
.c-jupiter { color: var(--jupiter); fill: var(--jupiter); }
.c-saturn  { color: var(--saturn);  fill: var(--saturn); }
</style>
</head>
<body>

<div id="ghost"></div>
<div id="tip"></div>

<div class="app">
  <div class="header">
    <h1>Astro Chart</h1>
    <p>Drag planets onto the wheel · drag placed planets to move · double-tap to remove</p>
  </div>

  <div class="asc-bar">
    <span class="asc-label">ASC Sign</span>
    <select class="asc-select" id="ascSelect">
      <option value="0">♈ Aries</option>
      <option value="1">♉ Taurus</option>
      <option value="2">♊ Gemini</option>
      <option value="3">♋ Cancer</option>
      <option value="4">♌ Leo</option>
      <option value="5">♍ Virgo</option>
      <option value="6">♎ Libra</option>
      <option value="7">♏ Scorpio</option>
      <option value="8">♐ Sagittarius</option>
      <option value="9">♑ Capricorn</option>
      <option value="10">♒ Aquarius</option>
      <option value="11">♓ Pisces</option>
    </select>
  </div>

  <div class="chart-wrap" id="chartWrap">
    <svg id="chart-svg" viewBox="0 0 400 400">
      <g id="g-sectors"></g>
      <g id="g-ticks"></g>
      <g id="g-signs"></g>
      <g id="g-asc"></g>
      <g id="g-planets"></g>
    </svg>
  </div>

  <div class="bank-row" id="bank">
    <div class="pcard c-sun"     data-pid="sun">     <span class="sym">☉</span><span class="lbl">Sun</span></div>
    <div class="pcard c-moon"    data-pid="moon">    <span class="sym">☽</span><span class="lbl">Moon</span></div>
    <div class="pcard c-mercury" data-pid="mercury"> <span class="sym">☿</span><span class="lbl">Merc</span></div>
    <div class="pcard c-venus"   data-pid="venus">   <span class="sym">♀</span><span class="lbl">Venus</span></div>
    <div class="pcard c-mars"    data-pid="mars">    <span class="sym">♂</span><span class="lbl">Mars</span></div>
    <div class="pcard c-jupiter" data-pid="jupiter"> <span class="sym">♃</span><span class="lbl">Jup</span></div>
    <div class="pcard c-saturn"  data-pid="saturn">  <span class="sym">♄</span><span class="lbl">Saturn</span></div>
  </div>

  <button class="clear-btn" id="clearBtn">✕  Clear Chart</button>
</div>

<script>
(function () {
'use strict';

/* ═══════════════════════════════════════════════════════════════
   DESIGN NOTES — why the touch system is built this way:

   Problem with the previous version:
   • onTS was passive:true  →  preventDefault() silently ignored
     → browser scrolled the page the moment a finger moved
   • Drag only started after >10px movement with a threshold check,
     but by then the browser already "won" the scroll gesture
   • Two separate touchstart handlers (global onTS + per-element
     handlePlanetTouchStart) fought each other

   Solution:
   • ONE touchstart listener, capture phase, passive:false
     so we can call preventDefault() the instant we recognise
     a drag on a planet card or placed planet
   • ONE touchmove listener, passive:false, always calls
     preventDefault() once a drag is active
   • ONE touchend/cancel listener
   • No movement threshold — drag starts immediately on touchstart
     for instant response. Double-tap is detected by timestamp.
   • chart-wrap has touch-action:none (browser never scrolls over it)
   • bank-row has touch-action:none (browser never scrolls over it)
   • body has touch-action:pan-y (normal scroll elsewhere)
═══════════════════════════════════════════════════════════════ */

const NS = 'http://www.w3.org/2000/svg';
const CX = 200, CY = 200;
const R_OUT        = 183;
const R_ZOD        = 162;
const R_ZOD_MID    = 173;
const R_IN         = 140;
const R_PLANET     = 110;   // outermost planet orbit radius
const R_INNER_FACE = 60;
const ASC_SCREEN   = 180;   // chart 0° sits at screen left (180° in math angle)

let ASC_SIGN_INDEX = 0;

const SIGNS = ['♈','♉','♊','♋','♌','♍','♎','♏','♐','♑','♒','♓'];
const SIGN_NAMES = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo',
                    'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];
const PLANETS = {
  sun:     { sym:'☉', name:'Sun' },
  moon:    { sym:'☽', name:'Moon' },
  mercury: { sym:'☿', name:'Mercury' },
  venus:   { sym:'♀', name:'Venus' },
  mars:    { sym:'♂', name:'Mars' },
  jupiter: { sym:'♃', name:'Jupiter' },
  saturn:  { sym:'♄', name:'Saturn' },
};

// chartData: planetId → chart degrees (0–360, where 0 = ASC cusp)
const chartData = new Map();

/* ── SVG helpers ─────────────────────────────── */
function mkEl(tag, attrs, parent) {
  const e = document.createElementNS(NS, tag);
  for (const [k, v] of Object.entries(attrs || {})) e.setAttribute(k, v);
  if (parent) parent.appendChild(e);
  return e;
}

// chart degrees → screen radians
function cDegToRad(deg) {
  return ((deg + ASC_SCREEN) % 360) * Math.PI / 180;
}

function polar(r, rad) {
  return { x: CX + r * Math.cos(rad), y: CY + r * Math.sin(rad) };
}

/* ── Coordinate conversion ───────────────────── */
// screen clientX/Y → chart degrees (0–360)
function clientToChartDeg(cx, cy) {
  const wrap = document.getElementById('chartWrap');
  const rect = wrap.getBoundingClientRect();
  // map client → SVG viewBox (400×400)
  const vx = (cx - rect.left) / rect.width  * 400;
  const vy = (cy - rect.top)  / rect.height * 400;
  const rad = Math.atan2(vy - CY, vx - CX);
  const screenDeg = ((rad * 180 / Math.PI) + 360) % 360;
  return ((screenDeg - ASC_SCREEN) + 360) % 360;
}

// Is client position inside the circular chart area?
function overChart(cx, cy) {
  const wrap = document.getElementById('chartWrap');
  const rect = wrap.getBoundingClientRect();
  const dx = cx - (rect.left + rect.width / 2);
  const dy = cy - (rect.top  + rect.height / 2);
  return dx*dx + dy*dy <= (rect.width/2) * (rect.height/2);
}

/* ── Build static chart ───────────────────────── */
function buildChart() {
  ['g-sectors','g-ticks','g-signs','g-asc'].forEach(id =>
    document.getElementById(id).innerHTML = '');

  const gS = document.getElementById('g-sectors');
  const gT = document.getElementById('g-ticks');
  const gSg = document.getElementById('g-signs');
  const gA  = document.getElementById('g-asc');

  // Outer background disc
  mkEl('circle', { cx:CX, cy:CY, r:R_OUT, fill:'#fffef8', stroke:'var(--spoke)', 'stroke-width':1 }, gS);

  // 12 house/sign sectors
  for (let i = 0; i < 12; i++) {
    const a1   = cDegToRad(i * 30);
    const a2   = cDegToRad((i + 1) * 30);
    const midA = cDegToRad(i * 30 + 15);

    // Zodiac band arc
    const zp1 = polar(R_ZOD, a1), zp2 = polar(R_ZOD, a2);
    const ip1 = polar(R_IN,  a1), ip2 = polar(R_IN,  a2);
    mkEl('path', {
      d: `M${zp1.x},${zp1.y} A${R_ZOD},${R_ZOD} 0 0,1 ${zp2.x},${zp2.y}` +
         `L${ip2.x},${ip2.y} A${R_IN},${R_IN} 0 0,0 ${ip1.x},${ip1.y}Z`,
      fill: i%2===0 ? 'var(--ring-even)' : 'var(--ring-odd)',
      stroke: 'var(--spoke)', 'stroke-width': '0.5'
    }, gS);

    // House wedge (inner area)
    mkEl('path', {
      d: `M${CX},${CY} L${ip1.x},${ip1.y} A${R_IN},${R_IN} 0 0,1 ${ip2.x},${ip2.y}Z`,
      fill: 'none', stroke: 'var(--spoke)', 'stroke-width': '0.4'
    }, gS);

    // House number — rotates with ASC
    const hNum = ((i - ASC_SIGN_INDEX + 12) % 12) + 1;
    const hnPos = polar(R_IN - 18, midA);
    const ht = mkEl('text', { x: hnPos.x, y: hnPos.y, class: 'house-n',
      'text-anchor':'middle', 'dominant-baseline':'middle' }, gS);
    ht.textContent = hNum;

    // Zodiac sign symbol — rotates with ASC
    const signIdx = (ASC_SIGN_INDEX + i) % 12;
    const smPos = polar(R_ZOD_MID - 4, midA);
    const st = mkEl('text', { x: smPos.x, y: smPos.y, class: 'sign-sym',
      'text-anchor':'middle', 'dominant-baseline':'middle' }, gSg);
    st.textContent = SIGNS[signIdx];
    bindSignTip(st, signIdx);
  }

  // Degree ticks
  for (let d = 0; d < 360; d++) {
    const a   = cDegToRad(d);
    const maj = d % 30 === 0;
    const mid = d % 5  === 0;
    const len = maj ? 11 : mid ? 6 : 3.5;
    const p1 = polar(R_OUT, a), p2 = polar(R_OUT - len, a);
    mkEl('line', { x1:p1.x, y1:p1.y, x2:p2.x, y2:p2.y,
      class: maj ? 'tick-major' : 'tick-minor' }, gT);
  }

  // Inner centre circle
  mkEl('circle', { cx:CX, cy:CY, r:R_INNER_FACE, class:'inner-ring' }, gS);

  // ASC line
  const ascRad = cDegToRad(0);
  const al1 = polar(R_INNER_FACE, ascRad), al2 = polar(R_OUT + 5, ascRad);
  mkEl('line', { x1:al1.x, y1:al1.y, x2:al2.x, y2:al2.y, class:'asc-line' }, gA);
  const alp = polar(R_OUT + 14, ascRad);
  const at = mkEl('text', { x:alp.x, y:alp.y, class:'asc-lbl',
    'text-anchor':'middle', 'dominant-baseline':'middle' }, gA);
  at.textContent = 'ASC';
}

/* ── Render placed planets ───────────────────── */
function render() {
  const g = document.getElementById('g-planets');
  g.innerHTML = '';

  // Sync bank card states
  document.querySelectorAll('.pcard').forEach(card => {
    const pid = card.dataset.pid;
    card.classList.toggle('used',    chartData.has(pid));
    card.classList.toggle('lifting', drag.active && drag.pid === pid && drag.src === 'bank');
  });

  // Stack planets that land close together
  const buckets = new Map();
  chartData.forEach((deg, pid) => {
    const key = Math.round(deg / 4) * 4;
    if (!buckets.has(key)) buckets.set(key, []);
    buckets.get(key).push(pid);
  });

  chartData.forEach((deg, pid) => {
    const key = Math.round(deg / 4) * 4;
    const grp = buckets.get(key);
    const idx = grp.indexOf(pid);
    const r   = R_PLANET - idx * 22;    // push stacked planets inward
    const rad = cDegToRad(deg);
    const pos = polar(r, rad);
    const degInSign = Math.floor(deg % 30);

    // Glyph
    const pt = mkEl('text', {
      x: pos.x, y: pos.y,
      class: `p-glyph c-${pid}`,
      'data-pid': pid,
      'text-anchor': 'middle',
      'dominant-baseline': 'middle'
    }, g);
    pt.textContent = PLANETS[pid].sym;

    // Degree label (toward centre)
    const dp = polar(r - 15, rad);
    const dt = mkEl('text', { x:dp.x, y:dp.y, class:'p-deg' }, g);
    dt.textContent = `${degInSign}°`;

    // Mouse tooltip + drag
    pt.addEventListener('mouseenter', e => showTip(planetTip(pid, deg), e.clientX, e.clientY));
    pt.addEventListener('mousemove',  e => moveTip(e.clientX, e.clientY));
    pt.addEventListener('mouseleave', hideTip);
    pt.addEventListener('mousedown',  e => { e.preventDefault(); beginDrag('chart', pid, e.clientX, e.clientY); });
    pt.addEventListener('dblclick',   () => { chartData.delete(pid); render(); });
  });
}

function planetTip(pid, deg) {
  return `${PLANETS[pid].name}  ·  ${SIGN_NAMES[Math.floor(deg/30)]}  ${Math.floor(deg%30)}°`;
}

/* ── Tooltip ─────────────────────────────────── */
const tipEl = document.getElementById('tip');
let tipTO = null;
function showTip(txt, cx, cy) {
  clearTimeout(tipTO);
  tipEl.textContent = txt;
  tipEl.classList.add('show');
  moveTip(cx, cy);
}
function moveTip(cx, cy) {
  tipEl.style.left = '-999px'; tipEl.style.top = '-999px';
  const tw = tipEl.offsetWidth, th = tipEl.offsetHeight;
  let tx = cx + 12, ty = cy - th - 8;
  if (tx + tw > window.innerWidth - 6) tx = cx - tw - 12;
  if (ty < 4) ty = cy + 14;
  tipEl.style.left = tx + 'px'; tipEl.style.top = ty + 'px';
}
function hideTip() { tipTO = setTimeout(() => tipEl.classList.remove('show'), 80); }
function bindSignTip(el, idx) {
  el.addEventListener('mouseenter', e => showTip(SIGN_NAMES[idx], e.clientX, e.clientY));
  el.addEventListener('mousemove',  e => moveTip(e.clientX, e.clientY));
  el.addEventListener('mouseleave', hideTip);
}

/* ── Ghost ───────────────────────────────────── */
const ghostEl = document.getElementById('ghost');
function showGhost(sym, cx, cy) {
  ghostEl.textContent = sym;
  ghostEl.style.left = cx + 'px';
  ghostEl.style.top  = cy + 'px';
  ghostEl.classList.add('show');
}
function moveGhost(cx, cy) {
  ghostEl.style.left = cx + 'px';
  ghostEl.style.top  = cy + 'px';
}
function hideGhost() { ghostEl.classList.remove('show'); }

/* ══════════════════════════════════════════════
   DRAG STATE
   src: 'bank' | 'chart'
   We keep one clean object and reset it fully
   after every gesture.
══════════════════════════════════════════════ */
const drag = {
  active:  false,
  src:     null,     // 'bank' | 'chart'
  pid:     null,     // planet id
  touchId: null,     // active touch identifier
  lastTap: new Map() // pid → Date.now() for double-tap
};

function resetDrag() {
  drag.active  = false;
  drag.src     = null;
  drag.pid     = null;
  drag.touchId = null;
}

function beginDrag(src, pid, cx, cy) {
  drag.active = true;
  drag.src    = src;
  drag.pid    = pid;
  hideTip();
  showGhost(PLANETS[pid].sym, cx, cy);
  if (src === 'chart') {
    // Remove from chart immediately — ghost replaces it visually
    chartData.delete(pid);
  }
  render(); // update bank (grey out source card)
}

function updateDrag(cx, cy) {
  moveGhost(cx, cy);
  document.getElementById('chartWrap').classList.toggle('over', overChart(cx, cy));
}

function commitDrag(cx, cy) {
  if (!drag.active) return;
  hideGhost();
  document.getElementById('chartWrap').classList.remove('over');

  if (overChart(cx, cy)) {
    chartData.set(drag.pid, clientToChartDeg(cx, cy));
  }
  // If dropped outside chart and src was 'chart', planet is simply removed
  // (already deleted in beginDrag). If src was 'bank', nothing placed — fine.

  resetDrag();
  render();
}

function abortDrag() {
  if (!drag.active) return;
  hideGhost();
  document.getElementById('chartWrap').classList.remove('over');
  // Note: if we dragged from chart, the planet was deleted in beginDrag.
  // On abort we just leave it removed (simpler, avoids needing to save original pos).
  resetDrag();
  render();
}

/* ══════════════════════════════════════════════
   MOUSE EVENTS (desktop)
══════════════════════════════════════════════ */
document.querySelectorAll('.pcard').forEach(card => {
  card.setAttribute('draggable', 'true');
  card.addEventListener('dragstart', e => e.dataTransfer.setData('text/plain', card.dataset.pid));
  card.addEventListener('mousedown', e => {
    if (card.classList.contains('used')) return;
    e.preventDefault();
    beginDrag('bank', card.dataset.pid, e.clientX, e.clientY);
  });
});

window.addEventListener('mousemove', e => { if (drag.active) updateDrag(e.clientX, e.clientY); });
window.addEventListener('mouseup',   e => { if (drag.active) commitDrag(e.clientX, e.clientY); });

// HTML5 drag-and-drop fallback (desktop only)
const cw = document.getElementById('chartWrap');
cw.addEventListener('dragover',  e => { e.preventDefault(); cw.classList.add('over'); });
cw.addEventListener('dragleave', () => cw.classList.remove('over'));
cw.addEventListener('drop', e => {
  e.preventDefault(); cw.classList.remove('over');
  const pid = e.dataTransfer.getData('text/plain');
  if (pid) { chartData.set(pid, clientToChartDeg(e.clientX, e.clientY)); render(); }
});

/* ══════════════════════════════════════════════
   TOUCH EVENTS (mobile)

   All three listeners are on `document`, capture
   phase, passive:false — this is the only way to
   reliably call preventDefault() and win the
   gesture race against the browser's scroll.

   We call preventDefault() ONLY when our drag is
   active, so normal page scroll works everywhere
   else (body has touch-action:pan-y as fallback).
══════════════════════════════════════════════ */
document.addEventListener('touchstart',  onTouchStart,  { capture:true, passive:false });
document.addEventListener('touchmove',   onTouchMove,   { capture:true, passive:false });
document.addEventListener('touchend',    onTouchEnd,    { capture:true, passive:false });
document.addEventListener('touchcancel', onTouchCancel, { capture:true, passive:false });

function findTouch(list, id) {
  for (let i = 0; i < list.length; i++) if (list[i].identifier === id) return list[i];
  return null;
}

function onTouchStart(e) {
  // Only handle a fresh single-touch (ignore if drag already active)
  if (drag.active) return;

  const t = e.changedTouches[0];
  const tgt = document.elementFromPoint(t.clientX, t.clientY);
  if (!tgt) return;

  // ── Is the touch on a bank card? ──────────────
  const card = tgt.closest('.pcard');
  if (card && !card.classList.contains('used')) {
    e.preventDefault();                      // block scroll immediately
    drag.touchId = t.identifier;
    beginDrag('bank', card.dataset.pid, t.clientX, t.clientY);
    return;
  }

  // ── Is the touch on a placed planet glyph? ───
  // Walk up from tgt through SVG element hierarchy
  let node = tgt;
  while (node && node !== document.body) {
    if (node.classList && node.classList.contains('p-glyph')) {
      const pid = node.getAttribute('data-pid');
      if (pid && chartData.has(pid)) {
        // Double-tap to remove
        const now = Date.now();
        const prev = drag.lastTap.get(pid) || 0;
        drag.lastTap.set(pid, now);
        if (now - prev < 350) {
          e.preventDefault();
          chartData.delete(pid);
          drag.lastTap.delete(pid);
          render();
          return;
        }
        // Single tap → begin drag
        e.preventDefault();                  // block scroll immediately
        drag.touchId = t.identifier;
        beginDrag('chart', pid, t.clientX, t.clientY);
        return;
      }
    }
    node = node.parentNode;
  }
  // Touch on something else — don't intercept, let page scroll normally
}

function onTouchMove(e) {
  if (!drag.active) return;
  const t = findTouch(e.touches, drag.touchId);
  if (!t) return;
  e.preventDefault();                        // keep blocking scroll while dragging
  updateDrag(t.clientX, t.clientY);
}

function onTouchEnd(e) {
  if (!drag.active) return;
  const t = findTouch(e.changedTouches, drag.touchId);
  if (!t) return;
  e.preventDefault();
  commitDrag(t.clientX, t.clientY);
}

function onTouchCancel() {
  if (drag.active) abortDrag();
}

/* ── ASC selector ────────────────────────────── */
document.getElementById('ascSelect').addEventListener('change', e => {
  ASC_SIGN_INDEX = parseInt(e.target.value);
  buildChart();
  render();
});

/* ── Clear ───────────────────────────────────── */
document.getElementById('clearBtn').addEventListener('click', () => {
  chartData.clear(); render();
});

/* ── Boot ────────────────────────────────────── */
buildChart();
render();

})();
</script>
</body>
</html>
