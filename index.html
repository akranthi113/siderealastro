<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>AstroPro · Chart Builder</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;800&family=Crimson+Pro:ital,wght@0,300;0,400;1,300&display=swap');

        :root {
            --bg: #f5f0eb;
            --surface: #ffffff;
            --border: #ddd5c8;
            --border-mid: #c8bdb0;
            --text: #2c2416;
            --text-dim: #8a7a68;
            --accent: #7c5c2e;
            --accent2: #c0392b;
            --sun: #c47a0a;
            --moon: #4a6d9a;
            --mercury: #6b2fae;
            --venus: #b01050;
            --mars: #b52020;
            --jupiter: #985200;
            --saturn: #246b5e;
            --chart-bg: #fffef8;
            --chart-sector: #faf6f0;
            --chart-sector-alt: #f5ede4;
            --chart-line: #d4c9bc;
            --chart-line-major: #a89882;
            --zodiac-fill: #a89882;
            --house-num-fill: #c8b8a8;
        }

        /* ── Reset & Base ── */
        *, *::before, *::after { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        html {
            /* Prevent elastic/rubber-band scroll while dragging */
            overscroll-behavior: none;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: 'Crimson Pro', Georgia, serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 16px 12px 40px;
            /* Do NOT put touch-action:manipulation on body — it breaks planet scrubbing */
            background-image:
                radial-gradient(ellipse at 30% 10%, rgba(180,140,80,0.07) 0%, transparent 55%),
                radial-gradient(ellipse at 70% 90%, rgba(120,80,180,0.04) 0%, transparent 55%);
            user-select: none;
            -webkit-user-select: none;
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.28em;
            color: var(--text-dim);
            text-transform: uppercase;
            margin: 0 0 14px;
        }

        .container {
            width: 100%;
            max-width: 480px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        /* ── Chart ── */
        .chart-wrapper {
            width: 100%;
            aspect-ratio: 1/1;
            position: relative;
            /* Critically: block ALL touch actions on the chart so the browser
               never tries to scroll while user is dragging over it */
            touch-action: none;
            border-radius: 50%;
            background: var(--chart-bg);
            box-shadow:
                0 0 0 1px var(--border),
                0 4px 24px rgba(100,70,30,0.12),
                inset 0 0 40px rgba(200,180,150,0.08);
            transition: box-shadow 0.2s;
        }

        .chart-wrapper.drag-over {
            box-shadow:
                0 0 0 2.5px var(--accent),
                0 4px 32px rgba(124,92,46,0.22),
                inset 0 0 40px rgba(200,180,150,0.08);
        }

        svg { width: 100%; height: 100%; display: block; overflow: visible; }

        .house-sector     { fill: var(--chart-sector);     stroke: var(--chart-line); stroke-width: 0.7; }
        .house-sector-alt { fill: var(--chart-sector-alt); stroke: var(--chart-line); stroke-width: 0.7; }
        .tick-line        { stroke: var(--chart-line);       stroke-width: 0.7; }
        .tick-major       { stroke: var(--chart-line-major); stroke-width: 1.4; }

        .zodiac-text {
            font-size: 15px;
            fill: var(--zodiac-fill);
            font-family: 'Cinzel', serif;
            pointer-events: all;
            cursor: default;
            transition: fill 0.15s;
        }
        .zodiac-text:hover { fill: var(--accent); }

        .house-num {
            font-size: 9px;
            fill: var(--house-num-fill);
            font-weight: 800;
            font-family: 'Cinzel', serif;
            pointer-events: none;
        }

        .degree-label {
            font-size: 9px;
            fill: var(--text-dim);
            font-weight: 400;
            pointer-events: none;
            font-family: 'Crimson Pro', serif;
        }

        .chart-planet {
            font-size: 22px;
            cursor: move;
            text-anchor: middle;
            dominant-baseline: middle;
            transition: font-size 0.12s;
        }
        .chart-planet:hover { font-size: 27px; }

        .asc-label {
            font-size: 9px;
            fill: var(--accent2);
            font-family: 'Cinzel', serif;
            font-weight: 600;
            letter-spacing: 0.1em;
            pointer-events: none;
        }

        /* ── Tooltip ── */
        #tooltip {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            background: var(--surface);
            border: 1px solid var(--border-mid);
            color: var(--text);
            font-family: 'Cinzel', serif;
            font-size: 11px;
            letter-spacing: 0.07em;
            padding: 5px 11px 4px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(100,70,30,0.14);
            white-space: nowrap;
            opacity: 0;
            transform: translateY(4px);
            transition: opacity 0.14s, transform 0.14s;
            left: -9999px; /* keep offscreen when hidden so it doesn't affect layout */
        }
        #tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* ── Planet Bank ── */
        .bank-label {
            font-family: 'Cinzel', serif;
            font-size: 10px;
            letter-spacing: 0.2em;
            color: var(--text-dim);
            text-align: center;
            text-transform: uppercase;
        }

        .bank {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            padding: 12px;
            background: var(--surface);
            border-radius: 16px;
            border: 1px solid var(--border);
            box-shadow: 0 2px 10px rgba(100,70,30,0.06);
            /* Bank itself should not scroll - use auto for normal page scroll above/below */
            touch-action: pan-y;
        }

        .planet-btn {
            aspect-ratio: 1/1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            font-size: 20px;
            line-height: 1;
            cursor: grab;
            background: var(--bg);
            border-radius: 12px;
            border: 1px solid var(--border);
            box-shadow: 0 1px 4px rgba(100,70,30,0.07);
            transition: transform 0.15s, opacity 0.2s, box-shadow 0.2s, background 0.15s;
            user-select: none;
            -webkit-user-select: none;
            /* Prevent the long-press magnifier / context menu on iOS */
            -webkit-touch-callout: none;
            touch-action: none; /* Each button blocks touch so we handle it ourselves */
        }

        .planet-btn .pname {
            font-family: 'Cinzel', serif;
            font-size: 5.5px;
            letter-spacing: 0.03em;
            color: var(--text-dim);
            line-height: 1;
            text-transform: uppercase;
        }

        .planet-btn:hover     { transform: scale(1.09); box-shadow: 0 4px 12px rgba(100,70,30,0.14); }
        .planet-btn.dragging  { opacity: 0.35; transform: scale(0.94); }
        .planet-btn.placed    { opacity: 0.18; filter: grayscale(1); pointer-events: none; }

        /* Ghost element that follows the finger */
        #touch-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            font-size: 40px;
            line-height: 1;
            transform: translate(-50%, -60%); /* slightly above finger tip */
            opacity: 0.9;
            filter: drop-shadow(0 3px 8px rgba(0,0,0,0.18));
            display: none;
        }

        .hint {
            text-align: center;
            font-size: 12px;
            color: var(--text-dim);
            font-style: italic;
            line-height: 1.6;
            margin: 0;
        }

        .ui-btn {
            width: 100%;
            padding: 13px;
            border-radius: 12px;
            border: 1px solid #e8c8c8;
            background: #fff5f5;
            color: #c0392b;
            font-weight: 700;
            font-size: 12px;
            font-family: 'Cinzel', serif;
            letter-spacing: 0.12em;
            cursor: pointer;
            transition: background 0.2s, box-shadow 0.2s;
            touch-action: manipulation; /* tap only, no scroll confusion */
        }
        .ui-btn:hover { background: #fdecea; box-shadow: 0 4px 16px rgba(192,57,43,0.10); }

        .c-sun     { fill: var(--sun);     color: var(--sun); }
        .c-moon    { fill: var(--moon);    color: var(--moon); }
        .c-mercury { fill: var(--mercury); color: var(--mercury); }
        .c-venus   { fill: var(--venus);   color: var(--venus); }
        .c-mars    { fill: var(--mars);    color: var(--mars); }
        .c-jupiter { fill: var(--jupiter); color: var(--jupiter); }
        .c-saturn  { fill: var(--saturn);  color: var(--saturn); }
    </style>
</head>
<body>

<!-- Persistent ghost div — moved by JS, never recreated -->
<div id="touch-ghost"></div>
<div id="tooltip"></div>

<div class="container">
    <h1>✦ Astro Chart Builder</h1>

    <div class="chart-wrapper" id="dropzone">
        <svg id="chart" viewBox="0 0 400 400">
            <defs>
                <radialGradient id="chartGrad" cx="50%" cy="50%" r="50%">
                    <stop offset="0%"   stop-color="#fffef8"/>
                    <stop offset="100%" stop-color="#f4ece0"/>
                </radialGradient>
            </defs>
            <circle cx="200" cy="200" r="196" fill="url(#chartGrad)" stroke="#ddd5c8" stroke-width="1"/>
            <circle cx="200" cy="200" r="115" fill="#faf8f3"          stroke="#ddd5c8" stroke-width="0.8"/>
            <g id="ticks-layer"></g>
            <g id="houses-layer"></g>
            <g id="zodiac-layer"></g>
            <g id="planets-layer"></g>
        </svg>
    </div>

    <p class="hint">Drag planets onto the chart · Hover/tap to see names<br>Slide left/right on a placed planet to adjust degree · Double-tap to remove</p>

    <div class="bank-label">Planets</div>
    <div class="bank" id="bank">
        <button class="planet-btn c-sun"     data-id="sun">☉<span class="pname">Sun</span></button>
        <button class="planet-btn c-moon"    data-id="moon">☽<span class="pname">Moon</span></button>
        <button class="planet-btn c-mercury" data-id="mercury">☿<span class="pname">Mercury</span></button>
        <button class="planet-btn c-venus"   data-id="venus">♀<span class="pname">Venus</span></button>
        <button class="planet-btn c-mars"    data-id="mars">♂<span class="pname">Mars</span></button>
        <button class="planet-btn c-jupiter" data-id="jupiter">♃<span class="pname">Jupiter</span></button>
        <button class="planet-btn c-saturn"  data-id="saturn">♄<span class="pname">Saturn</span></button>
    </div>

    <button class="ui-btn" id="resetBtn">✕ Clear Chart</button>
</div>

<script>
/* =============================================================================
   AstroPro Chart Builder — fully fixed mobile touch handling
   Key design decisions:
   1. ONE global touchmove + touchend listener — never use passive:true when we
      need to call preventDefault() to stop scroll.
   2. A persistent #touch-ghost div avoids repeated DOM create/destroy.
   3. Planet-bank buttons use touch-action:none so the browser won't preemptively
      claim the touch for scrolling before we get a chance to handle it.
   4. Chart wrapper uses touch-action:none to fully own its touch surface.
   5. Scrub state is stored in a module-level object, not closure vars, so it
      survives re-renders triggered during the same gesture.
   ========================================================================== */
(() => {
    'use strict';

    const svgNS        = "http://www.w3.org/2000/svg";
    const CENTER       = 200;
    const INNER_R      = 115;
    const OUTER_R      = 185;
    const MID_R        = 148;
    const ASC_OFFSET   = 90;
    const VIEWBOX_SIZE = 400;

    // ── Data ──────────────────────────────────────────────────────────────────
    const chartState = new Map(); // planetId → { house:0-11, degree:0-29.9 }

    const SYMBOLS      = { sun:"☉", moon:"☽", mercury:"☿", venus:"♀", mars:"♂", jupiter:"♃", saturn:"♄" };
    const PLANET_NAMES = { sun:"Sun", moon:"Moon", mercury:"Mercury", venus:"Venus", mars:"Mars", jupiter:"Jupiter", saturn:"Saturn" };
    const ZODIAC_SYM   = ["♈","♉","♊","♋","♌","♍","♎","♏","♐","♑","♒","♓"];
    const ZODIAC_NAMES = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"];

    // ── Global gesture state ──────────────────────────────────────────────────
    // Only ONE gesture can be active at a time.
    // mode: null | 'drag-from-bank' | 'scrub'
    const gesture = {
        mode:      null,
        planetId:  null,   // id of planet being dragged or scrubbed
        startX:    0,
        startDeg:  0,
        moved:     false,  // did finger move enough to count as drag vs tap?
    };

    const ghost    = document.getElementById("touch-ghost");
    const dropzone = document.getElementById("dropzone");

    // ── Tooltip ───────────────────────────────────────────────────────────────
    const tipEl = document.getElementById("tooltip");
    let   tipTO = null;

    function showTip(text, x, y) {
        clearTimeout(tipTO);
        tipEl.textContent = text;
        tipEl.classList.add("visible");
        moveTip(x, y);
    }
    function moveTip(x, y) {
        // Temporarily place offscreen to measure natural width
        tipEl.style.left = "-9999px";
        tipEl.style.top  = "-9999px";
        const tw = tipEl.offsetWidth;
        const th = tipEl.offsetHeight;
        let tx = x + 14;
        let ty = y - th - 10;
        if (tx + tw > window.innerWidth - 8)  tx = x - tw - 14;
        if (ty < 8)                             ty = y + 16;
        tipEl.style.left = tx + "px";
        tipEl.style.top  = ty + "px";
    }
    function hideTip(delay) {
        clearTimeout(tipTO);
        tipTO = setTimeout(() => tipEl.classList.remove("visible"), delay ?? 0);
    }

    // ── SVG helpers ───────────────────────────────────────────────────────────
    function degToRad(d) { return d * Math.PI / 180; }
    function pt(r, a)    { return { x: CENTER + r * Math.cos(a), y: CENTER + r * Math.sin(a) }; }

    function createSVGEl(tag, attrs) {
        const el = document.createElementNS(svgNS, tag);
        for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
        return el;
    }

    function addSVGText(val, r, a, cls, parent) {
        const p = pt(r, a);
        const t = createSVGEl("text", {
            x: p.x, y: p.y, class: cls,
            "text-anchor": "middle", "dominant-baseline": "middle"
        });
        t.textContent = val;
        parent.appendChild(t);
        return t;
    }

    // ── Convert screen coords → chart {house, degree} ─────────────────────────
    function clientToChartPos(clientX, clientY) {
        const rect   = dropzone.getBoundingClientRect();
        const scaleX = VIEWBOX_SIZE / rect.width;
        const scaleY = VIEWBOX_SIZE / rect.height;
        const vbX    = (clientX - rect.left) * scaleX;
        const vbY    = (clientY - rect.top)  * scaleY;
        let   angle  = Math.atan2(vbY - CENTER, vbX - CENTER) * (180 / Math.PI) + ASC_OFFSET;
        angle        = ((angle % 360) + 360) % 360;
        return {
            house:  Math.floor(angle / 30),
            degree: parseFloat((angle % 30).toFixed(1))
        };
    }

    function isOverDropzone(clientX, clientY) {
        const r = dropzone.getBoundingClientRect();
        return clientX >= r.left && clientX <= r.right &&
               clientY >= r.top  && clientY <= r.bottom;
    }

    // ── Init chart drawing ────────────────────────────────────────────────────
    function init() {
        const ticksG  = document.getElementById("ticks-layer");
        const housesG = document.getElementById("houses-layer");
        const zodiacG = document.getElementById("zodiac-layer");

        // Degree tick marks
        for (let d = 0; d < 360; d++) {
            const a   = degToRad(d - ASC_OFFSET);
            const maj = d % 30 === 0;
            const mid = d % 5  === 0;
            const len = maj ? 12 : (mid ? 7 : 4);
            ticksG.appendChild(createSVGEl("line", {
                x1: pt(OUTER_R, a).x,         y1: pt(OUTER_R, a).y,
                x2: pt(OUTER_R - len, a).x,   y2: pt(OUTER_R - len, a).y,
                class: maj ? "tick-major" : "tick-line"
            }));
        }

        // 12 house sectors
        for (let i = 0; i < 12; i++) {
            const sA   = degToRad(i * 30 - ASC_OFFSET);
            const eA   = degToRad((i + 1) * 30 - ASC_OFFSET);
            const midA = degToRad(i * 30 + 15 - ASC_OFFSET);
            const p0 = pt(OUTER_R, sA), p1 = pt(OUTER_R, eA);
            const p2 = pt(INNER_R, eA), p3 = pt(INNER_R, sA);

            housesG.appendChild(createSVGEl("path", {
                d: `M${p0.x},${p0.y} A${OUTER_R},${OUTER_R} 0 0 1 ${p1.x},${p1.y}` +
                   `L${p2.x},${p2.y} A${INNER_R},${INNER_R} 0 0 0 ${p3.x},${p3.y}Z`,
                class: i % 2 === 0 ? "house-sector" : "house-sector-alt"
            }));

            // Divider spoke
            housesG.appendChild(createSVGEl("line", {
                x1: pt(INNER_R, sA).x, y1: pt(INNER_R, sA).y,
                x2: pt(OUTER_R, sA).x, y2: pt(OUTER_R, sA).y,
                class: "tick-major"
            }));

            // House number
            addSVGText(i + 1, INNER_R + 18, midA, "house-num", housesG);

            // Zodiac symbol (interactive)
            const zx = pt(OUTER_R + 22, midA).x;
            const zy = pt(OUTER_R + 22, midA).y;
            const zTxt = createSVGEl("text", {
                x: zx, y: zy, class: "zodiac-text",
                "text-anchor": "middle", "dominant-baseline": "middle"
            });
            zTxt.textContent = ZODIAC_SYM[i];
            // Mouse tooltip
            zTxt.addEventListener("mouseenter", (e) => showTip(ZODIAC_NAMES[i], e.clientX, e.clientY));
            zTxt.addEventListener("mousemove",  (e) => moveTip(e.clientX, e.clientY));
            zTxt.addEventListener("mouseleave", () => hideTip(80));
            zodiacG.appendChild(zTxt);
        }

        // ASC marker
        const ascA = degToRad(-ASC_OFFSET);
        zodiacG.appendChild(createSVGEl("line", {
            x1: pt(INNER_R - 4, ascA).x, y1: pt(INNER_R - 4, ascA).y,
            x2: pt(OUTER_R + 4, ascA).x, y2: pt(OUTER_R + 4, ascA).y,
            stroke: "#c0392b", "stroke-width": "2"
        }));
        addSVGText("ASC", OUTER_R + 38, ascA, "asc-label", zodiacG);
    }

    // ── Render placed planets ─────────────────────────────────────────────────
    function render() {
        const layer = document.getElementById("planets-layer");
        layer.innerHTML = "";

        // Update bank button states
        document.querySelectorAll(".planet-btn").forEach(btn => {
            const placed = chartState.has(btn.dataset.id);
            btn.classList.toggle("placed", placed);
            // Keep dragging visual while gesture is active
            btn.classList.toggle("dragging",
                gesture.mode === "drag-from-bank" && gesture.planetId === btn.dataset.id);
        });

        // Group nearby planets for stacking (avoid exact overlap)
        const posIndex = new Map();

        chartState.forEach((data, id) => {
            const totalDeg = data.house * 30 + data.degree;
            // Bucket by 3-degree slots for stacking
            const key = Math.floor(totalDeg / 3);
            const idx = posIndex.get(key) || 0;
            posIndex.set(key, idx + 1);

            const radius = MID_R + idx * 22;
            const angle  = degToRad(totalDeg - ASC_OFFSET);
            const pos    = pt(radius, angle);
            const lblPos = pt(radius + 20, angle);

            const g = document.createElementNS(svgNS, "g");

            // Planet glyph
            const pTxt = createSVGEl("text", { x: pos.x, y: pos.y, class: `chart-planet c-${id}` });
            pTxt.textContent = SYMBOLS[id];

            // Degree label
            const dTxt = createSVGEl("text", { x: lblPos.x, y: lblPos.y, class: "degree-label" });
            dTxt.textContent = `${Math.floor(data.degree)}°`;

            // Mouse hover tooltip
            const makeTipText = () =>
                `${PLANET_NAMES[id]}  ·  ${ZODIAC_NAMES[data.house]}  ${Math.floor(data.degree)}°`;

            pTxt.addEventListener("mouseenter", (e) => showTip(makeTipText(), e.clientX, e.clientY));
            pTxt.addEventListener("mousemove",  (e) => moveTip(e.clientX, e.clientY));
            pTxt.addEventListener("mouseleave", () => hideTip(80));

            // Mouse double-click to remove
            pTxt.addEventListener("dblclick", () => {
                hideTip();
                chartState.delete(id);
                render();
            });

            // Mouse scrub (mousedown → mousemove)
            pTxt.addEventListener("mousedown", (e) => {
                e.preventDefault();
                hideTip();
                startMouseScrub(id, data, e.clientX);
            });

            g.appendChild(dTxt);
            g.appendChild(pTxt);
            layer.appendChild(g);
        });
    }

    // ── Mouse scrub ───────────────────────────────────────────────────────────
    function startMouseScrub(id, data, startX) {
        const startDeg = data.degree;
        let   moved    = false;

        const onMove = (e) => {
            e.preventDefault();
            moved = true;
            data.degree = clampDegree(startDeg + (e.clientX - startX) / 3);
            render();
        };
        const onUp = () => {
            window.removeEventListener("mousemove", onMove);
            window.removeEventListener("mouseup",   onUp);
        };
        window.addEventListener("mousemove", onMove);
        window.addEventListener("mouseup",   onUp);
    }

    function clampDegree(d) { return Math.max(0.0, Math.min(29.9, d)); }

    // ═══════════════════════════════════════════════════════════════════════════
    //  UNIFIED TOUCH SYSTEM
    //  One touchstart on the whole document (capture phase) + one touchmove +
    //  one touchend. This is the only reliable way to:
    //    • prevent page scroll while dragging from bank → chart
    //    • prevent page scroll while scrubbing a placed planet
    //    • still allow normal page scroll everywhere else
    // ═══════════════════════════════════════════════════════════════════════════

    // We need a persistent touch identifier so we can ignore extra fingers
    let activeTouchId = null;

    document.addEventListener("touchstart", onTouchStart, { passive: false });
    document.addEventListener("touchmove",  onTouchMove,  { passive: false });
    document.addEventListener("touchend",   onTouchEnd,   { passive: false });
    document.addEventListener("touchcancel",onTouchEnd,   { passive: false });

    function getTouchById(touches, id) {
        for (let i = 0; i < touches.length; i++) {
            if (touches[i].identifier === id) return touches[i];
        }
        return null;
    }

    function onTouchStart(e) {
        // If a gesture is already running, ignore new fingers
        if (gesture.mode !== null) return;

        const touch = e.changedTouches[0];
        const target = touch.target;

        // ── Case 1: Touching a planet bank button ────────────────────────────
        const btn = target.closest(".planet-btn");
        if (btn && !btn.classList.contains("placed")) {
            // Prevent scroll immediately — we're starting a drag
            e.preventDefault();
            activeTouchId     = touch.identifier;
            gesture.mode      = "drag-from-bank";
            gesture.planetId  = btn.dataset.id;
            gesture.startX    = touch.clientX;
            gesture.moved     = false;

            // Show ghost at finger position
            ghost.textContent = SYMBOLS[gesture.planetId];
            ghost.style.left  = touch.clientX + "px";
            ghost.style.top   = touch.clientY + "px";
            ghost.style.display = "block";

            // Dim the source button
            render();
            return;
        }

        // ── Case 2: Touching a placed planet on the chart (scrub / remove) ──
        // SVG text elements don't have .closest(), walk up manually
        let el = target;
        let planetId = null;
        while (el && el !== document.body) {
            if (el.classList && el.classList.contains("chart-planet")) {
                // Extract id from class list: "chart-planet c-sun" → "sun"
                for (const cls of el.classList) {
                    if (cls.startsWith("c-") && cls !== "chart-planet") {
                        planetId = cls.slice(2);
                        break;
                    }
                }
                break;
            }
            el = el.parentElement;
        }

        if (planetId && chartState.has(planetId)) {
            // Prevent scroll — we're scrubbing
            e.preventDefault();
            activeTouchId     = touch.identifier;
            gesture.mode      = "scrub";
            gesture.planetId  = planetId;
            gesture.startX    = touch.clientX;
            gesture.startDeg  = chartState.get(planetId).degree;
            gesture.moved     = false;

            // Show tooltip for context
            const data = chartState.get(planetId);
            showTip(
                `${PLANET_NAMES[planetId]}  ·  ${ZODIAC_NAMES[data.house]}  ${Math.floor(data.degree)}°`,
                touch.clientX, touch.clientY
            );
        }
        // Everything else: do nothing, let the browser scroll normally
    }

    function onTouchMove(e) {
        if (gesture.mode === null) return;

        const touch = getTouchById(e.changedTouches, activeTouchId) ||
                      getTouchById(e.touches, activeTouchId);
        if (!touch) return;

        // Always prevent scroll while a gesture is active
        e.preventDefault();
        gesture.moved = true;

        const cx = touch.clientX;
        const cy = touch.clientY;

        if (gesture.mode === "drag-from-bank") {
            // Move ghost
            ghost.style.left = cx + "px";
            ghost.style.top  = cy + "px";
            // Highlight chart if finger is over it
            dropzone.classList.toggle("drag-over", isOverDropzone(cx, cy));

        } else if (gesture.mode === "scrub") {
            const data = chartState.get(gesture.planetId);
            if (data) {
                data.degree = clampDegree(gesture.startDeg + (cx - gesture.startX) / 3);
                // Update tooltip live
                hideTip(0);
                showTip(
                    `${PLANET_NAMES[gesture.planetId]}  ·  ${ZODIAC_NAMES[data.house]}  ${Math.floor(data.degree)}°`,
                    cx, cy
                );
                render();
            }
        }
    }

    function onTouchEnd(e) {
        if (gesture.mode === null) return;

        const touch = getTouchById(e.changedTouches, activeTouchId);
        if (!touch) return;

        e.preventDefault(); // prevent ghost click / tap events

        const cx = touch.clientX;
        const cy = touch.clientY;

        if (gesture.mode === "drag-from-bank") {
            // Hide ghost
            ghost.style.display = "none";
            dropzone.classList.remove("drag-over");

            if (isOverDropzone(cx, cy)) {
                chartState.set(gesture.planetId, clientToChartPos(cx, cy));
            }

        } else if (gesture.mode === "scrub") {
            hideTip(1200);

            if (!gesture.moved) {
                // It was a tap, not a scrub — check for double-tap removal
                const now = Date.now();
                const lastTap = tapTimestamps.get(gesture.planetId) || 0;
                if (now - lastTap < 350) {
                    chartState.delete(gesture.planetId);
                    hideTip(0);
                }
                tapTimestamps.set(gesture.planetId, now);
            }
        }

        // Reset gesture
        gesture.mode     = null;
        gesture.planetId = null;
        gesture.moved    = false;
        activeTouchId    = null;

        render();
    }

    // Tracks last tap time per planet for double-tap detection
    const tapTimestamps = new Map();

    // ── Desktop Drag & Drop (mouse) ───────────────────────────────────────────
    document.querySelectorAll(".planet-btn").forEach(btn => {
        btn.setAttribute("draggable", "true");
        btn.addEventListener("dragstart", (e) => {
            e.dataTransfer.setData("text/plain", btn.dataset.id);
            e.dataTransfer.effectAllowed = "copy";
        });
    });

    dropzone.addEventListener("dragover",  (e) => { e.preventDefault(); dropzone.classList.add("drag-over"); });
    dropzone.addEventListener("dragleave", ()  => dropzone.classList.remove("drag-over"));
    dropzone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropzone.classList.remove("drag-over");
        const id = e.dataTransfer.getData("text/plain");
        if (!id) return;
        chartState.set(id, clientToChartPos(e.clientX, e.clientY));
        render();
    });

    // ── Reset button ──────────────────────────────────────────────────────────
    document.getElementById("resetBtn").addEventListener("click", () => {
        chartState.clear();
        render();
    });

    // ── Boot ──────────────────────────────────────────────────────────────────
    init();
    render();
})();
</script>
</body>
</html>
