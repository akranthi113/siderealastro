<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Astro Chart Builder</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Inter:wght@400;500;600&display=swap');

:root {
  --bg:        #f7f4ef;
  --white:     #ffffff;
  --border:    #e0d8cc;
  --text:      #1a1510;
  --muted:     #7a6f62;
  --accent:    #5c4a2a;
  --red:       #b83232;

  --sun:     #c47a0a;
  --moon:    #3d6494;
  --mercury: #6b2fae;
  --venus:   #a01248;
  --mars:    #b02020;
  --jupiter: #8a4a00;
  --saturn:  #1e6b5a;

  --chart-face: #fffef8;
  --ring-even:  #faf5ed;
  --ring-odd:   #f3ece0;
  --spoke:      #ccc0b0;
  --tick:       #b8a898;
  --sign-color: #9a8878;
}

*, *::before, *::after {
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  user-select: none;
  -webkit-user-select: none;
}

html, body {
  margin: 0; padding: 0;
  overscroll-behavior: none;
}

body {
  background: var(--bg);
  font-family: 'Inter', system-ui, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  padding: 18px 12px 36px;
}

.app { width: 100%; max-width: 420px; display: flex; flex-direction: column; gap: 16px; }

/* ── Header ── */
.header {
  text-align: center;
}
.header h1 {
  font-family: 'Cinzel', serif;
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 0.25em;
  color: var(--muted);
  text-transform: uppercase;
  margin: 0 0 4px;
}
.header p {
  font-size: 11px;
  color: var(--muted);
  margin: 0;
  opacity: 0.7;
}

/* ── Chart ── */
.chart-wrap {
  width: 100%;
  aspect-ratio: 1;
  position: relative;
  /* touch-action none = browser hands ALL touches to JS, no scroll interference */
  touch-action: none;
}

#chart-svg {
  width: 100%; height: 100%;
  display: block;
  /* flat 2D - no shadows, no gradients */
  border-radius: 50%;
  border: 1.5px solid var(--border);
  background: var(--chart-face);
}

/* SVG element styles */
.ring-even   { fill: var(--ring-even); }
.ring-odd    { fill: var(--ring-odd); }
.spoke       { stroke: var(--spoke); stroke-width: 1; }
.tick-minor  { stroke: var(--tick); stroke-width: 0.6; }
.tick-major  { stroke: var(--spoke); stroke-width: 1.2; }
.sign-sym    { font-size: 13px; fill: var(--sign-color); font-family: 'Cinzel', serif; cursor: default; }
.house-n     { font-size: 8px; fill: #bbb0a0; font-family: 'Inter', sans-serif; font-weight: 600; }
.asc-line    { stroke: var(--red); stroke-width: 1.5; }
.asc-lbl     { font-size: 8px; fill: var(--red); font-family: 'Cinzel', serif; font-weight: 600; }
.inner-ring  { fill: var(--chart-face); stroke: var(--spoke); stroke-width: 1; }

/* Planet on chart */
.p-glyph {
  font-size: 20px;
  text-anchor: middle;
  dominant-baseline: middle;
  cursor: grab;
}
.p-glyph:active { cursor: grabbing; }
.p-deg {
  font-size: 8px;
  fill: var(--muted);
  font-family: 'Inter', sans-serif;
  pointer-events: none;
  text-anchor: middle;
  dominant-baseline: middle;
}

/* Drag-over ring highlight */
.chart-wrap.over #chart-svg {
  border-color: var(--accent);
  background: #fefcf4;
}

/* ── Tooltip ── */
#tip {
  position: fixed;
  z-index: 9999;
  pointer-events: none;
  background: var(--white);
  border: 1px solid var(--border);
  color: var(--text);
  font-family: 'Cinzel', serif;
  font-size: 10.5px;
  letter-spacing: 0.06em;
  padding: 4px 10px;
  border-radius: 6px;
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.12s;
  top: -99px; left: -99px;
}
#tip.show { opacity: 1; }

/* ── Bank ── */
.bank-row {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 7px;
  padding: 10px;
  background: var(--white);
  border: 1px solid var(--border);
  border-radius: 14px;
}

.pcard {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  aspect-ratio: 1;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: var(--bg);
  /* touch-action none — we fully own these touches */
  touch-action: none;
  cursor: grab;
  transition: opacity 0.18s, border-color 0.15s, transform 0.1s;
  gap: 2px;
}
.pcard span.sym  { font-size: 20px; line-height: 1; display: block; }
.pcard span.lbl  {
  font-family: 'Cinzel', serif;
  font-size: 5px;
  letter-spacing: 0.04em;
  color: var(--muted);
  text-transform: uppercase;
  line-height: 1;
}
.pcard.used      { opacity: 0.2; filter: grayscale(1); pointer-events: none; }
.pcard.lifting   { opacity: 0.4; transform: scale(0.9); }

/* Ghost that follows finger */
#ghost {
  position: fixed;
  pointer-events: none;
  z-index: 9000;
  font-size: 36px;
  line-height: 1;
  transform: translate(-50%, -65%);
  opacity: 0;
  transition: opacity 0.1s;
}
#ghost.show { opacity: 0.85; }

/* ── Clear button ── */
.clear-btn {
  width: 100%;
  padding: 12px;
  border: 1px solid #f0d0d0;
  background: #fff8f8;
  color: var(--red);
  font-family: 'Cinzel', serif;
  font-size: 11px;
  letter-spacing: 0.12em;
  font-weight: 600;
  border-radius: 10px;
  cursor: pointer;
  touch-action: manipulation;
}
.clear-btn:active { background: #fdecea; }

/* colour tokens per planet */
.c-sun     { color: var(--sun);     fill: var(--sun); }
.c-moon    { color: var(--moon);    fill: var(--moon); }
.c-mercury { color: var(--mercury); fill: var(--mercury); }
.c-venus   { color: var(--venus);   fill: var(--venus); }
.c-mars    { color: var(--mars);    fill: var(--mars); }
.c-jupiter { color: var(--jupiter); fill: var(--jupiter); }
.c-saturn  { color: var(--saturn);  fill: var(--saturn); }
</style>
</head>
<body>

<div id="ghost"></div>
<div id="tip"></div>

<div class="app">

  <div class="header">
    <h1>Astro Chart</h1>
    <p>Drag planets onto the wheel · drag to move · double-tap to remove</p>
  </div>

  <div class="chart-wrap" id="chartWrap">
    <svg id="chart-svg" viewBox="0 0 400 400">
      <g id="g-sectors"></g>
      <g id="g-ticks"></g>
      <g id="g-signs"></g>
      <g id="g-planets"></g>
    </svg>
  </div>

  <div class="bank-row" id="bank">
    <div class="pcard c-sun"     data-pid="sun">     <span class="sym">☉</span><span class="lbl">Sun</span></div>
    <div class="pcard c-moon"    data-pid="moon">    <span class="sym">☽</span><span class="lbl">Moon</span></div>
    <div class="pcard c-mercury" data-pid="mercury"> <span class="sym">☿</span><span class="lbl">Merc</span></div>
    <div class="pcard c-venus"   data-pid="venus">   <span class="sym">♀</span><span class="lbl">Venus</span></div>
    <div class="pcard c-mars"    data-pid="mars">    <span class="sym">♂</span><span class="lbl">Mars</span></div>
    <div class="pcard c-jupiter" data-pid="jupiter"> <span class="sym">♃</span><span class="lbl">Jup</span></div>
    <div class="pcard c-saturn"  data-pid="saturn">  <span class="sym">♄</span><span class="lbl">Saturn</span></div>
  </div>

  <button class="clear-btn" id="clearBtn">✕  Clear Chart</button>
</div>

<script>
(function () {
'use strict';

/* ─────────────────────────────────────────────
   CONSTANTS
───────────────────────────────────────────── */
const NS   = 'http://www.w3.org/2000/svg';
const CX   = 200, CY = 200;          // SVG centre
const R_OUT = 183;                    // outer tick ring
const R_ZOD = 162;                    // zodiac band outer
const R_ZOD_MID = 173;               // zodiac symbol radius
const R_IN  = 140;                    // inner working ring
const R_PLANET = 110;                 // where planets sit
const R_INNER_FACE = 60;             // blank centre circle

// We offset so Aries/house-1 starts at the left (9 o'clock = 180°)
// ASC (0°) is at angle 180° in standard math coords
const ASC_DEG = 180;

const SIGNS = ['♈','♉','♊','♋','♌','♍','♎','♏','♐','♑','♒','♓'];
const SIGN_NAMES = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo',
                    'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];
const PLANETS = {
  sun:     { sym:'☉', name:'Sun' },
  moon:    { sym:'☽', name:'Moon' },
  mercury: { sym:'☿', name:'Mercury' },
  venus:   { sym:'♀', name:'Venus' },
  mars:    { sym:'♂', name:'Mars' },
  jupiter: { sym:'♃', name:'Jupiter' },
  saturn:  { sym:'♄', name:'Saturn' },
};

/* ─────────────────────────────────────────────
   STATE
   chartData: Map<planetId, angleDeg>
   angleDeg = 0..360, where 0 = Aries cusp = left of chart
───────────────────────────────────────────── */
const chartData = new Map();

/* ─────────────────────────────────────────────
   SVG HELPERS
───────────────────────────────────────────── */
function el(tag, attrs, parent) {
  const e = document.createElementNS(NS, tag);
  for (const [k, v] of Object.entries(attrs || {})) e.setAttribute(k, v);
  if (parent) parent.appendChild(e);
  return e;
}

// chart angle → screen angle (radians)
// chart 0° (Aries) = left = 180° screen
function chartToRad(chartDeg) {
  return ((chartDeg + ASC_DEG) % 360) * Math.PI / 180;
}

function polarXY(r, rad) {
  return { x: CX + r * Math.cos(rad), y: CY + r * Math.sin(rad) };
}

// screen clientX/Y → chart degree (0-360)
function clientToChartDeg(cx, cy) {
  const wrap = document.getElementById('chartWrap');
  const rect = wrap.getBoundingClientRect();
  const px = (cx - rect.left) / rect.width  * 400;
  const py = (cy - rect.top)  / rect.height * 400;
  const dx = px - CX, dy = py - CY;
  const screenRad = Math.atan2(dy, dx);         // -π..π
  const screenDeg = ((screenRad * 180 / Math.PI) + 360) % 360; // 0..360
  const chartDeg  = ((screenDeg - ASC_DEG) + 360) % 360;
  return chartDeg;
}

function isOverChart(cx, cy) {
  const wrap = document.getElementById('chartWrap');
  const rect = wrap.getBoundingClientRect();
  const px = cx - rect.left, py = cy - rect.top;
  const dx = px - rect.width/2, dy = py - rect.height/2;
  const r2 = dx*dx + dy*dy;
  const maxR = rect.width / 2;
  return r2 <= maxR * maxR;
}

/* ─────────────────────────────────────────────
   DRAW STATIC CHART
───────────────────────────────────────────── */
function buildChart() {
  const gSectors = document.getElementById('g-sectors');
  const gTicks   = document.getElementById('g-ticks');
  const gSigns   = document.getElementById('g-signs');

  // Background circle
  el('circle', { cx: CX, cy: CY, r: R_OUT, fill: '#fffef8', stroke: 'var(--spoke)', 'stroke-width': 1 }, gSectors);

  // 12 house sectors (alternating fill)
  for (let i = 0; i < 12; i++) {
    const a1 = chartToRad(i * 30);
    const a2 = chartToRad((i + 1) * 30);
    const p1 = polarXY(R_ZOD, a1), p2 = polarXY(R_ZOD, a2);
    const p3 = polarXY(R_IN,  a2), p4 = polarXY(R_IN,  a1);
    // Zodiac band sector
    el('path', {
      d: `M${p1.x},${p1.y} A${R_ZOD},${R_ZOD} 0 0,1 ${p2.x},${p2.y} L${p3.x},${p3.y} A${R_IN},${R_IN} 0 0,0 ${p4.x},${p4.y}Z`,
      fill: i%2===0 ? 'var(--ring-even)' : 'var(--ring-odd)',
      stroke: 'var(--spoke)', 'stroke-width': '0.5'
    }, gSectors);

    // House inner sector
    const pi1 = polarXY(R_IN, a1), pi2 = polarXY(R_IN, a2);
    const pc1 = { x: CX, y: CY };
    el('path', {
      d: `M${CX},${CY} L${pi1.x},${pi1.y} A${R_IN},${R_IN} 0 0,1 ${pi2.x},${pi2.y}Z`,
      fill: 'none',
      stroke: 'var(--spoke)', 'stroke-width': '0.5'
    }, gSectors);

    // House number
    const midRad = chartToRad(i * 30 + 15);
    const hn = polarXY(R_IN - 18, midRad);
    const t = el('text', { x: hn.x, y: hn.y, class: 'house-n', 'text-anchor': 'middle', 'dominant-baseline': 'middle' }, gSectors);
    t.textContent = i + 1;

    // Zodiac symbol (with hover tooltip)
    const sm = polarXY(R_ZOD_MID - 4, midRad);
    const st = el('text', { x: sm.x, y: sm.y, class: 'sign-sym', 'text-anchor': 'middle', 'dominant-baseline': 'middle' }, gSigns);
    st.textContent = SIGNS[i];
    bindSignTooltip(st, i);
  }

  // Degree tick marks on outer ring
  for (let d = 0; d < 360; d++) {
    const a = chartToRad(d);
    const isMaj = d % 30 === 0;
    const isMid = d % 5  === 0;
    const len   = isMaj ? 11 : isMid ? 6 : 3.5;
    const p1 = polarXY(R_OUT,       a);
    const p2 = polarXY(R_OUT - len, a);
    el('line', { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, class: isMaj ? 'tick-major' : 'tick-minor' }, gTicks);
  }

  // Inner centre face
  el('circle', { cx: CX, cy: CY, r: R_INNER_FACE, class: 'inner-ring' }, gSectors);

  // ASC line & label (left = 180° screen = chart 0° Aries)
  const ascRad = chartToRad(0);
  const a1 = polarXY(R_INNER_FACE, ascRad), a2 = polarXY(R_OUT + 4, ascRad);
  el('line', { x1: a1.x, y1: a1.y, x2: a2.x, y2: a2.y, class: 'asc-line' }, gSigns);
  const alp = polarXY(R_OUT + 14, ascRad);
  const at = el('text', { x: alp.x, y: alp.y, class: 'asc-lbl', 'text-anchor': 'middle', 'dominant-baseline': 'middle' }, gSigns);
  at.textContent = 'ASC';
}

/* ─────────────────────────────────────────────
   RENDER PLANETS
───────────────────────────────────────────── */
function render() {
  const g = document.getElementById('g-planets');
  g.innerHTML = '';

  // Update bank cards
  document.querySelectorAll('.pcard').forEach(card => {
    const pid = card.dataset.pid;
    card.classList.toggle('used', chartData.has(pid));
    card.classList.toggle('lifting',
      drag.active && drag.src === 'bank' && drag.pid === pid);
  });

  // Spread overlapping planets
  const byBucket = new Map();
  chartData.forEach((deg, pid) => {
    const bucket = Math.round(deg / 5) * 5;
    if (!byBucket.has(bucket)) byBucket.set(bucket, []);
    byBucket.get(bucket).push(pid);
  });

  chartData.forEach((deg, pid) => {
    const bucket = Math.round(deg / 5) * 5;
    const group  = byBucket.get(bucket);
    const idx    = group.indexOf(pid);
    // Stagger radius for stacked planets
    const r      = R_PLANET - idx * 22;
    const rad    = chartToRad(deg);
    const pos    = polarXY(r, rad);

    const signIdx = Math.floor(deg / 30);
    const degInSign = Math.floor(deg % 30);

    // Planet glyph
    const pt = el('text', {
      x: pos.x, y: pos.y,
      class: `p-glyph c-${pid}`,
      'data-pid': pid,
      'text-anchor': 'middle',
      'dominant-baseline': 'middle'
    }, g);
    pt.textContent = PLANETS[pid].sym;

    // Degree badge just inside (toward centre) of planet
    const degPos = polarXY(r - 16, rad);
    const dt = el('text', { x: degPos.x, y: degPos.y, class: 'p-deg' }, g);
    dt.textContent = `${degInSign}°`;

    // Mouse hover tooltip
    pt.addEventListener('mouseenter', e => showTip(makePlanetTip(pid, deg), e.clientX, e.clientY));
    pt.addEventListener('mousemove',  e => moveTip(e.clientX, e.clientY));
    pt.addEventListener('mouseleave', hideTip);

    // Mouse drag to reposition
    pt.addEventListener('mousedown', e => {
      e.preventDefault();
      startDrag('chart', pid, e.clientX, e.clientY);
    });

    // Double-click to remove
    pt.addEventListener('dblclick', () => {
      chartData.delete(pid);
      render();
    });
  });
}

function makePlanetTip(pid, deg) {
  const s = Math.floor(deg / 30);
  const d = Math.floor(deg % 30);
  return `${PLANETS[pid].name}  ·  ${SIGN_NAMES[s]}  ${d}°`;
}

/* ─────────────────────────────────────────────
   TOOLTIP
───────────────────────────────────────────── */
const tipEl = document.getElementById('tip');
let tipTimer = null;

function showTip(text, cx, cy) {
  clearTimeout(tipTimer);
  tipEl.textContent = text;
  tipEl.classList.add('show');
  moveTip(cx, cy);
}
function moveTip(cx, cy) {
  tipEl.style.left = '-999px';
  tipEl.style.top  = '-999px';
  const tw = tipEl.offsetWidth, th = tipEl.offsetHeight;
  let tx = cx + 12, ty = cy - th - 8;
  if (tx + tw > window.innerWidth - 6) tx = cx - tw - 12;
  if (ty < 4) ty = cy + 14;
  tipEl.style.left = tx + 'px';
  tipEl.style.top  = ty + 'px';
}
function hideTip() {
  tipTimer = setTimeout(() => tipEl.classList.remove('show'), 80);
}

/* ─────────────────────────────────────────────
   SIGN TOOLTIP
───────────────────────────────────────────── */
function bindSignTooltip(el, idx) {
  el.addEventListener('mouseenter', e => showTip(SIGN_NAMES[idx], e.clientX, e.clientY));
  el.addEventListener('mousemove',  e => moveTip(e.clientX, e.clientY));
  el.addEventListener('mouseleave', hideTip);
}

/* ─────────────────────────────────────────────
   GHOST
───────────────────────────────────────────── */
const ghostEl = document.getElementById('ghost');

function showGhost(sym, cx, cy) {
  ghostEl.textContent = sym;
  ghostEl.style.left  = cx + 'px';
  ghostEl.style.top   = cy + 'px';
  ghostEl.classList.add('show');
}
function moveGhost(cx, cy) {
  ghostEl.style.left = cx + 'px';
  ghostEl.style.top  = cy + 'px';
}
function hideGhost() {
  ghostEl.classList.remove('show');
}

/* ─────────────────────────────────────────────
   DRAG STATE
   src: 'bank' | 'chart'
───────────────────────────────────────────── */
const drag = {
  active: false,
  src:    null,   // 'bank' | 'chart'
  pid:    null,
  touchId: null,
  lastTap: new Map(),   // pid → timestamp for double-tap detection
};

function startDrag(src, pid, cx, cy) {
  drag.active = true;
  drag.src    = src;
  drag.pid    = pid;
  hideTip();
  showGhost(PLANETS[pid].sym, cx, cy);
  // If dragging from chart, remove from chart immediately (ghost replaces it)
  if (src === 'chart') {
    chartData.delete(pid);
  }
  render();
}

function moveDragTo(cx, cy) {
  moveGhost(cx, cy);
  const wrap = document.getElementById('chartWrap');
  wrap.classList.toggle('over', isOverChart(cx, cy));
}

function endDrag(cx, cy) {
  if (!drag.active) return;
  drag.active = false;
  hideGhost();
  const wrap = document.getElementById('chartWrap');
  wrap.classList.remove('over');

  if (isOverChart(cx, cy)) {
    const deg = clientToChartDeg(cx, cy);
    chartData.set(drag.pid, deg);
  } else if (drag.src === 'chart') {
    // Dropped outside chart — just remove it (already deleted at startDrag)
  }

  drag.pid = null;
  drag.src = null;
  render();
}

function cancelDrag() {
  if (!drag.active) return;
  // If we were dragging from chart, put it back
  // (we can't easily restore original pos, so just remove it)
  drag.active = false;
  drag.pid = null;
  drag.src = null;
  hideGhost();
  const wrap = document.getElementById('chartWrap');
  wrap.classList.remove('over');
  render();
}

/* ─────────────────────────────────────────────
   MOUSE EVENTS (desktop)
───────────────────────────────────────────── */
// Bank card mousedown
document.querySelectorAll('.pcard').forEach(card => {
  card.setAttribute('draggable', 'true');
  card.addEventListener('mousedown', e => {
    if (card.classList.contains('used')) return;
    e.preventDefault();
    startDrag('bank', card.dataset.pid, e.clientX, e.clientY);
  });
  // HTML5 drag fallback
  card.addEventListener('dragstart', e => {
    e.dataTransfer.setData('text/plain', card.dataset.pid);
  });
});

window.addEventListener('mousemove', e => {
  if (!drag.active) return;
  moveDragTo(e.clientX, e.clientY);
});

window.addEventListener('mouseup', e => {
  if (!drag.active) return;
  endDrag(e.clientX, e.clientY);
});

// HTML5 drop fallback (desktop)
const chartWrap = document.getElementById('chartWrap');
chartWrap.addEventListener('dragover',  e => { e.preventDefault(); chartWrap.classList.add('over'); });
chartWrap.addEventListener('dragleave', () => chartWrap.classList.remove('over'));
chartWrap.addEventListener('drop', e => {
  e.preventDefault();
  chartWrap.classList.remove('over');
  const pid = e.dataTransfer.getData('text/plain');
  if (!pid) return;
  chartData.set(pid, clientToChartDeg(e.clientX, e.clientY));
  render();
});

/* ─────────────────────────────────────────────
   TOUCH EVENTS (mobile)
   Strategy:
   - ALL touchstart/move/end are captured at document level
   - passive:false everywhere so we can call preventDefault()
   - We ONLY call preventDefault() when OUR gesture is active,
     so normal page scroll still works when not touching a planet
───────────────────────────────────────────── */
document.addEventListener('touchstart', onTS, { passive: false, capture: true });
document.addEventListener('touchmove',  onTM, { passive: false, capture: true });
document.addEventListener('touchend',   onTE, { passive: false, capture: true });
document.addEventListener('touchcancel',onTC, { passive: false, capture: true });

function getTouch(list, id) {
  for (let i = 0; i < list.length; i++) if (list[i].identifier === id) return list[i];
  return null;
}

function onTS(e) {
  // Only handle single-finger, and only if no drag active
  if (drag.active) return;
  const t = e.changedTouches[0];
  const target = t.target;

  // ── Touching a bank card ─────────────────────────────────
  const card = target.closest('.pcard');
  if (card && !card.classList.contains('used')) {
    e.preventDefault();   // stop scroll
    drag.touchId = t.identifier;
    startDrag('bank', card.dataset.pid, t.clientX, t.clientY);
    return;
  }

  // ── Touching a planet already on chart ───────────────────
  // Walk up DOM from SVG target to find .p-glyph
  let node = target;
  while (node && node.tagName !== 'svg') {
    if (node.classList && node.classList.contains('p-glyph')) {
      const pid = node.getAttribute('data-pid');
      if (pid && chartData.has(pid)) {
        e.preventDefault();   // stop scroll
        drag.touchId = t.identifier;

        // Double-tap detection
        const now = Date.now();
        const prev = drag.lastTap.get(pid) || 0;
        if (now - prev < 350) {
          // Double-tap: remove
          chartData.delete(pid);
          drag.lastTap.delete(pid);
          render();
          return;
        }
        drag.lastTap.set(pid, now);

        startDrag('chart', pid, t.clientX, t.clientY);
        return;
      }
    }
    node = node.parentNode;
  }
  // Anything else: don't intercept, let scroll happen normally
}

function onTM(e) {
  if (!drag.active) return;
  const t = getTouch(e.changedTouches, drag.touchId) || getTouch(e.touches, drag.touchId);
  if (!t) return;
  e.preventDefault();   // block scroll while dragging
  moveDragTo(t.clientX, t.clientY);
}

function onTE(e) {
  if (!drag.active) return;
  const t = getTouch(e.changedTouches, drag.touchId);
  if (!t) return;
  e.preventDefault();
  endDrag(t.clientX, t.clientY);
  drag.touchId = null;
}

function onTC(e) {
  if (!drag.active) return;
  cancelDrag();
  drag.touchId = null;
}

/* ─────────────────────────────────────────────
   CLEAR
───────────────────────────────────────────── */
document.getElementById('clearBtn').addEventListener('click', () => {
  chartData.clear();
  render();
});

/* ─────────────────────────────────────────────
   BOOT
───────────────────────────────────────────── */
buildChart();
render();

})();
</script>
</body>
</html>
